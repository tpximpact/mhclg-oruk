"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/htmlparser2";
exports.ids = ["vendor-chunks/htmlparser2"];
exports.modules = {

/***/ "(rsc)/../../../node_modules/htmlparser2/lib/Parser.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/htmlparser2/lib/Parser.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parser = void 0;\nvar Tokenizer_js_1 = __importStar(__webpack_require__(/*! ./Tokenizer.js */ \"(rsc)/../../../node_modules/htmlparser2/lib/Tokenizer.js\"));\nvar decode_js_1 = __webpack_require__(/*! entities/lib/decode.js */ \"(rsc)/../../../node_modules/entities/lib/decode.js\");\nvar formTags = new Set([\n    \"input\",\n    \"option\",\n    \"optgroup\",\n    \"select\",\n    \"button\",\n    \"datalist\",\n    \"textarea\",\n]);\nvar pTag = new Set([\"p\"]);\nvar tableSectionTags = new Set([\"thead\", \"tbody\"]);\nvar ddtTags = new Set([\"dd\", \"dt\"]);\nvar rtpTags = new Set([\"rt\", \"rp\"]);\nvar openImpliesClose = new Map([\n    [\"tr\", new Set([\"tr\", \"th\", \"td\"])],\n    [\"th\", new Set([\"th\"])],\n    [\"td\", new Set([\"thead\", \"th\", \"td\"])],\n    [\"body\", new Set([\"head\", \"link\", \"script\"])],\n    [\"li\", new Set([\"li\"])],\n    [\"p\", pTag],\n    [\"h1\", pTag],\n    [\"h2\", pTag],\n    [\"h3\", pTag],\n    [\"h4\", pTag],\n    [\"h5\", pTag],\n    [\"h6\", pTag],\n    [\"select\", formTags],\n    [\"input\", formTags],\n    [\"output\", formTags],\n    [\"button\", formTags],\n    [\"datalist\", formTags],\n    [\"textarea\", formTags],\n    [\"option\", new Set([\"option\"])],\n    [\"optgroup\", new Set([\"optgroup\", \"option\"])],\n    [\"dd\", ddtTags],\n    [\"dt\", ddtTags],\n    [\"address\", pTag],\n    [\"article\", pTag],\n    [\"aside\", pTag],\n    [\"blockquote\", pTag],\n    [\"details\", pTag],\n    [\"div\", pTag],\n    [\"dl\", pTag],\n    [\"fieldset\", pTag],\n    [\"figcaption\", pTag],\n    [\"figure\", pTag],\n    [\"footer\", pTag],\n    [\"form\", pTag],\n    [\"header\", pTag],\n    [\"hr\", pTag],\n    [\"main\", pTag],\n    [\"nav\", pTag],\n    [\"ol\", pTag],\n    [\"pre\", pTag],\n    [\"section\", pTag],\n    [\"table\", pTag],\n    [\"ul\", pTag],\n    [\"rt\", rtpTags],\n    [\"rp\", rtpTags],\n    [\"tbody\", tableSectionTags],\n    [\"tfoot\", tableSectionTags],\n]);\nvar voidElements = new Set([\n    \"area\",\n    \"base\",\n    \"basefont\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"frame\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"isindex\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n]);\nvar foreignContextElements = new Set([\"math\", \"svg\"]);\nvar htmlIntegrationElements = new Set([\n    \"mi\",\n    \"mo\",\n    \"mn\",\n    \"ms\",\n    \"mtext\",\n    \"annotation-xml\",\n    \"foreignobject\",\n    \"desc\",\n    \"title\",\n]);\nvar reNameEnd = /\\s|\\//;\nvar Parser = /** @class */ (function () {\n    function Parser(cbs, options) {\n        if (options === void 0) { options = {}; }\n        var _a, _b, _c, _d, _e, _f;\n        this.options = options;\n        /** The start index of the last event. */\n        this.startIndex = 0;\n        /** The end index of the last event. */\n        this.endIndex = 0;\n        /**\n         * Store the start index of the current open tag,\n         * so we can update the start index for attributes.\n         */\n        this.openTagStart = 0;\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribvalue = \"\";\n        this.attribs = null;\n        this.stack = [];\n        this.buffers = [];\n        this.bufferOffset = 0;\n        /** The index of the last written buffer. Used when resuming after a `pause()`. */\n        this.writeIndex = 0;\n        /** Indicates whether the parser has finished running / `.end` has been called. */\n        this.ended = false;\n        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};\n        this.htmlMode = !this.options.xmlMode;\n        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : this.htmlMode;\n        this.lowerCaseAttributeNames =\n            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;\n        this.recognizeSelfClosing =\n            (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;\n        this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : Tokenizer_js_1.default)(this.options, this);\n        this.foreignContext = [!this.htmlMode];\n        (_f = (_e = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e, this);\n    }\n    // Tokenizer event handlers\n    /** @internal */\n    Parser.prototype.ontext = function (start, endIndex) {\n        var _a, _b;\n        var data = this.getSlice(start, endIndex);\n        this.endIndex = endIndex - 1;\n        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);\n        this.startIndex = endIndex;\n    };\n    /** @internal */\n    Parser.prototype.ontextentity = function (cp, endIndex) {\n        var _a, _b;\n        this.endIndex = endIndex - 1;\n        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));\n        this.startIndex = endIndex;\n    };\n    /**\n     * Checks if the current tag is a void element. Override this if you want\n     * to specify your own additional void elements.\n     */\n    Parser.prototype.isVoidElement = function (name) {\n        return this.htmlMode && voidElements.has(name);\n    };\n    /** @internal */\n    Parser.prototype.onopentagname = function (start, endIndex) {\n        this.endIndex = endIndex;\n        var name = this.getSlice(start, endIndex);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        this.emitOpenTag(name);\n    };\n    Parser.prototype.emitOpenTag = function (name) {\n        var _a, _b, _c, _d;\n        this.openTagStart = this.startIndex;\n        this.tagname = name;\n        var impliesClose = this.htmlMode && openImpliesClose.get(name);\n        if (impliesClose) {\n            while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {\n                var element = this.stack.shift();\n                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);\n            }\n        }\n        if (!this.isVoidElement(name)) {\n            this.stack.unshift(name);\n            if (this.htmlMode) {\n                if (foreignContextElements.has(name)) {\n                    this.foreignContext.unshift(true);\n                }\n                else if (htmlIntegrationElements.has(name)) {\n                    this.foreignContext.unshift(false);\n                }\n            }\n        }\n        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);\n        if (this.cbs.onopentag)\n            this.attribs = {};\n    };\n    Parser.prototype.endOpenTag = function (isImplied) {\n        var _a, _b;\n        this.startIndex = this.openTagStart;\n        if (this.attribs) {\n            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);\n            this.attribs = null;\n        }\n        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {\n            this.cbs.onclosetag(this.tagname, true);\n        }\n        this.tagname = \"\";\n    };\n    /** @internal */\n    Parser.prototype.onopentagend = function (endIndex) {\n        this.endIndex = endIndex;\n        this.endOpenTag(false);\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.onclosetag = function (start, endIndex) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.endIndex = endIndex;\n        var name = this.getSlice(start, endIndex);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        if (this.htmlMode &&\n            (foreignContextElements.has(name) ||\n                htmlIntegrationElements.has(name))) {\n            this.foreignContext.shift();\n        }\n        if (!this.isVoidElement(name)) {\n            var pos = this.stack.indexOf(name);\n            if (pos !== -1) {\n                for (var index = 0; index <= pos; index++) {\n                    var element = this.stack.shift();\n                    // We know the stack has sufficient elements.\n                    (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, index !== pos);\n                }\n            }\n            else if (this.htmlMode && name === \"p\") {\n                // Implicit open before close\n                this.emitOpenTag(\"p\");\n                this.closeCurrentTag(true);\n            }\n        }\n        else if (this.htmlMode && name === \"br\") {\n            // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.\n            (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, \"br\");\n            (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, \"br\", {}, true);\n            (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, \"br\", false);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.onselfclosingtag = function (endIndex) {\n        this.endIndex = endIndex;\n        if (this.recognizeSelfClosing || this.foreignContext[0]) {\n            this.closeCurrentTag(false);\n            // Set `startIndex` for next node\n            this.startIndex = endIndex + 1;\n        }\n        else {\n            // Ignore the fact that the tag is self-closing.\n            this.onopentagend(endIndex);\n        }\n    };\n    Parser.prototype.closeCurrentTag = function (isOpenImplied) {\n        var _a, _b;\n        var name = this.tagname;\n        this.endOpenTag(isOpenImplied);\n        // Self-closing tags will be on the top of the stack\n        if (this.stack[0] === name) {\n            // If the opening tag isn't implied, the closing tag has to be implied.\n            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);\n            this.stack.shift();\n        }\n    };\n    /** @internal */\n    Parser.prototype.onattribname = function (start, endIndex) {\n        this.startIndex = start;\n        var name = this.getSlice(start, endIndex);\n        this.attribname = this.lowerCaseAttributeNames\n            ? name.toLowerCase()\n            : name;\n    };\n    /** @internal */\n    Parser.prototype.onattribdata = function (start, endIndex) {\n        this.attribvalue += this.getSlice(start, endIndex);\n    };\n    /** @internal */\n    Parser.prototype.onattribentity = function (cp) {\n        this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);\n    };\n    /** @internal */\n    Parser.prototype.onattribend = function (quote, endIndex) {\n        var _a, _b;\n        this.endIndex = endIndex;\n        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double\n            ? '\"'\n            : quote === Tokenizer_js_1.QuoteType.Single\n                ? \"'\"\n                : quote === Tokenizer_js_1.QuoteType.NoValue\n                    ? undefined\n                    : null);\n        if (this.attribs &&\n            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {\n            this.attribs[this.attribname] = this.attribvalue;\n        }\n        this.attribvalue = \"\";\n    };\n    Parser.prototype.getInstructionName = function (value) {\n        var index = value.search(reNameEnd);\n        var name = index < 0 ? value : value.substr(0, index);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        return name;\n    };\n    /** @internal */\n    Parser.prototype.ondeclaration = function (start, endIndex) {\n        this.endIndex = endIndex;\n        var value = this.getSlice(start, endIndex);\n        if (this.cbs.onprocessinginstruction) {\n            var name = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(\"!\".concat(name), \"!\".concat(value));\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.onprocessinginstruction = function (start, endIndex) {\n        this.endIndex = endIndex;\n        var value = this.getSlice(start, endIndex);\n        if (this.cbs.onprocessinginstruction) {\n            var name = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(\"?\".concat(name), \"?\".concat(value));\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.oncomment = function (start, endIndex, offset) {\n        var _a, _b, _c, _d;\n        this.endIndex = endIndex;\n        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));\n        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.oncdata = function (start, endIndex, offset) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        this.endIndex = endIndex;\n        var value = this.getSlice(start, endIndex - offset);\n        if (!this.htmlMode || this.options.recognizeCDATA) {\n            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);\n            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);\n            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);\n        }\n        else {\n            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, \"[CDATA[\".concat(value, \"]]\"));\n            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.onend = function () {\n        var _a, _b;\n        if (this.cbs.onclosetag) {\n            // Set the end index for all remaining tags\n            this.endIndex = this.startIndex;\n            for (var index = 0; index < this.stack.length; index++) {\n                this.cbs.onclosetag(this.stack[index], true);\n            }\n        }\n        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    /**\n     * Resets the parser to a blank state, ready to parse a new HTML document\n     */\n    Parser.prototype.reset = function () {\n        var _a, _b, _c, _d;\n        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.tokenizer.reset();\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribs = null;\n        this.stack.length = 0;\n        this.startIndex = 0;\n        this.endIndex = 0;\n        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n        this.buffers.length = 0;\n        this.foreignContext.length = 0;\n        this.foreignContext.unshift(!this.htmlMode);\n        this.bufferOffset = 0;\n        this.writeIndex = 0;\n        this.ended = false;\n    };\n    /**\n     * Resets the parser, then parses a complete document and\n     * pushes it to the handler.\n     *\n     * @param data Document to parse.\n     */\n    Parser.prototype.parseComplete = function (data) {\n        this.reset();\n        this.end(data);\n    };\n    Parser.prototype.getSlice = function (start, end) {\n        while (start - this.bufferOffset >= this.buffers[0].length) {\n            this.shiftBuffer();\n        }\n        var slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);\n        while (end - this.bufferOffset > this.buffers[0].length) {\n            this.shiftBuffer();\n            slice += this.buffers[0].slice(0, end - this.bufferOffset);\n        }\n        return slice;\n    };\n    Parser.prototype.shiftBuffer = function () {\n        this.bufferOffset += this.buffers[0].length;\n        this.writeIndex--;\n        this.buffers.shift();\n    };\n    /**\n     * Parses a chunk of data and calls the corresponding callbacks.\n     *\n     * @param chunk Chunk to parse.\n     */\n    Parser.prototype.write = function (chunk) {\n        var _a, _b;\n        if (this.ended) {\n            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(\".write() after done!\"));\n            return;\n        }\n        this.buffers.push(chunk);\n        if (this.tokenizer.running) {\n            this.tokenizer.write(chunk);\n            this.writeIndex++;\n        }\n    };\n    /**\n     * Parses the end of the buffer and clears the stack, calls onend.\n     *\n     * @param chunk Optional final chunk to parse.\n     */\n    Parser.prototype.end = function (chunk) {\n        var _a, _b;\n        if (this.ended) {\n            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(\".end() after done!\"));\n            return;\n        }\n        if (chunk)\n            this.write(chunk);\n        this.ended = true;\n        this.tokenizer.end();\n    };\n    /**\n     * Pauses parsing. The parser won't emit events until `resume` is called.\n     */\n    Parser.prototype.pause = function () {\n        this.tokenizer.pause();\n    };\n    /**\n     * Resumes parsing after `pause` was called.\n     */\n    Parser.prototype.resume = function () {\n        this.tokenizer.resume();\n        while (this.tokenizer.running &&\n            this.writeIndex < this.buffers.length) {\n            this.tokenizer.write(this.buffers[this.writeIndex++]);\n        }\n        if (this.ended)\n            this.tokenizer.end();\n    };\n    /**\n     * Alias of `write`, for backwards compatibility.\n     *\n     * @param chunk Chunk to parse.\n     * @deprecated\n     */\n    Parser.prototype.parseChunk = function (chunk) {\n        this.write(chunk);\n    };\n    /**\n     * Alias of `end`, for backwards compatibility.\n     *\n     * @param chunk Optional final chunk to parse.\n     * @deprecated\n     */\n    Parser.prototype.done = function (chunk) {\n        this.end(chunk);\n    };\n    return Parser;\n}());\nexports.Parser = Parser;\n//# sourceMappingURL=Parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9QYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxrQ0FBa0MsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDMUQsa0JBQWtCLG1CQUFPLENBQUMsa0ZBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ab3J1ay9odWIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9QYXJzZXIuanM/Y2EzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJzZXIgPSB2b2lkIDA7XG52YXIgVG9rZW5pemVyX2pzXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vVG9rZW5pemVyLmpzXCIpKTtcbnZhciBkZWNvZGVfanNfMSA9IHJlcXVpcmUoXCJlbnRpdGllcy9saWIvZGVjb2RlLmpzXCIpO1xudmFyIGZvcm1UYWdzID0gbmV3IFNldChbXG4gICAgXCJpbnB1dFwiLFxuICAgIFwib3B0aW9uXCIsXG4gICAgXCJvcHRncm91cFwiLFxuICAgIFwic2VsZWN0XCIsXG4gICAgXCJidXR0b25cIixcbiAgICBcImRhdGFsaXN0XCIsXG4gICAgXCJ0ZXh0YXJlYVwiLFxuXSk7XG52YXIgcFRhZyA9IG5ldyBTZXQoW1wicFwiXSk7XG52YXIgdGFibGVTZWN0aW9uVGFncyA9IG5ldyBTZXQoW1widGhlYWRcIiwgXCJ0Ym9keVwiXSk7XG52YXIgZGR0VGFncyA9IG5ldyBTZXQoW1wiZGRcIiwgXCJkdFwiXSk7XG52YXIgcnRwVGFncyA9IG5ldyBTZXQoW1wicnRcIiwgXCJycFwiXSk7XG52YXIgb3BlbkltcGxpZXNDbG9zZSA9IG5ldyBNYXAoW1xuICAgIFtcInRyXCIsIG5ldyBTZXQoW1widHJcIiwgXCJ0aFwiLCBcInRkXCJdKV0sXG4gICAgW1widGhcIiwgbmV3IFNldChbXCJ0aFwiXSldLFxuICAgIFtcInRkXCIsIG5ldyBTZXQoW1widGhlYWRcIiwgXCJ0aFwiLCBcInRkXCJdKV0sXG4gICAgW1wiYm9keVwiLCBuZXcgU2V0KFtcImhlYWRcIiwgXCJsaW5rXCIsIFwic2NyaXB0XCJdKV0sXG4gICAgW1wibGlcIiwgbmV3IFNldChbXCJsaVwiXSldLFxuICAgIFtcInBcIiwgcFRhZ10sXG4gICAgW1wiaDFcIiwgcFRhZ10sXG4gICAgW1wiaDJcIiwgcFRhZ10sXG4gICAgW1wiaDNcIiwgcFRhZ10sXG4gICAgW1wiaDRcIiwgcFRhZ10sXG4gICAgW1wiaDVcIiwgcFRhZ10sXG4gICAgW1wiaDZcIiwgcFRhZ10sXG4gICAgW1wic2VsZWN0XCIsIGZvcm1UYWdzXSxcbiAgICBbXCJpbnB1dFwiLCBmb3JtVGFnc10sXG4gICAgW1wib3V0cHV0XCIsIGZvcm1UYWdzXSxcbiAgICBbXCJidXR0b25cIiwgZm9ybVRhZ3NdLFxuICAgIFtcImRhdGFsaXN0XCIsIGZvcm1UYWdzXSxcbiAgICBbXCJ0ZXh0YXJlYVwiLCBmb3JtVGFnc10sXG4gICAgW1wib3B0aW9uXCIsIG5ldyBTZXQoW1wib3B0aW9uXCJdKV0sXG4gICAgW1wib3B0Z3JvdXBcIiwgbmV3IFNldChbXCJvcHRncm91cFwiLCBcIm9wdGlvblwiXSldLFxuICAgIFtcImRkXCIsIGRkdFRhZ3NdLFxuICAgIFtcImR0XCIsIGRkdFRhZ3NdLFxuICAgIFtcImFkZHJlc3NcIiwgcFRhZ10sXG4gICAgW1wiYXJ0aWNsZVwiLCBwVGFnXSxcbiAgICBbXCJhc2lkZVwiLCBwVGFnXSxcbiAgICBbXCJibG9ja3F1b3RlXCIsIHBUYWddLFxuICAgIFtcImRldGFpbHNcIiwgcFRhZ10sXG4gICAgW1wiZGl2XCIsIHBUYWddLFxuICAgIFtcImRsXCIsIHBUYWddLFxuICAgIFtcImZpZWxkc2V0XCIsIHBUYWddLFxuICAgIFtcImZpZ2NhcHRpb25cIiwgcFRhZ10sXG4gICAgW1wiZmlndXJlXCIsIHBUYWddLFxuICAgIFtcImZvb3RlclwiLCBwVGFnXSxcbiAgICBbXCJmb3JtXCIsIHBUYWddLFxuICAgIFtcImhlYWRlclwiLCBwVGFnXSxcbiAgICBbXCJoclwiLCBwVGFnXSxcbiAgICBbXCJtYWluXCIsIHBUYWddLFxuICAgIFtcIm5hdlwiLCBwVGFnXSxcbiAgICBbXCJvbFwiLCBwVGFnXSxcbiAgICBbXCJwcmVcIiwgcFRhZ10sXG4gICAgW1wic2VjdGlvblwiLCBwVGFnXSxcbiAgICBbXCJ0YWJsZVwiLCBwVGFnXSxcbiAgICBbXCJ1bFwiLCBwVGFnXSxcbiAgICBbXCJydFwiLCBydHBUYWdzXSxcbiAgICBbXCJycFwiLCBydHBUYWdzXSxcbiAgICBbXCJ0Ym9keVwiLCB0YWJsZVNlY3Rpb25UYWdzXSxcbiAgICBbXCJ0Zm9vdFwiLCB0YWJsZVNlY3Rpb25UYWdzXSxcbl0pO1xudmFyIHZvaWRFbGVtZW50cyA9IG5ldyBTZXQoW1xuICAgIFwiYXJlYVwiLFxuICAgIFwiYmFzZVwiLFxuICAgIFwiYmFzZWZvbnRcIixcbiAgICBcImJyXCIsXG4gICAgXCJjb2xcIixcbiAgICBcImNvbW1hbmRcIixcbiAgICBcImVtYmVkXCIsXG4gICAgXCJmcmFtZVwiLFxuICAgIFwiaHJcIixcbiAgICBcImltZ1wiLFxuICAgIFwiaW5wdXRcIixcbiAgICBcImlzaW5kZXhcIixcbiAgICBcImtleWdlblwiLFxuICAgIFwibGlua1wiLFxuICAgIFwibWV0YVwiLFxuICAgIFwicGFyYW1cIixcbiAgICBcInNvdXJjZVwiLFxuICAgIFwidHJhY2tcIixcbiAgICBcIndiclwiLFxuXSk7XG52YXIgZm9yZWlnbkNvbnRleHRFbGVtZW50cyA9IG5ldyBTZXQoW1wibWF0aFwiLCBcInN2Z1wiXSk7XG52YXIgaHRtbEludGVncmF0aW9uRWxlbWVudHMgPSBuZXcgU2V0KFtcbiAgICBcIm1pXCIsXG4gICAgXCJtb1wiLFxuICAgIFwibW5cIixcbiAgICBcIm1zXCIsXG4gICAgXCJtdGV4dFwiLFxuICAgIFwiYW5ub3RhdGlvbi14bWxcIixcbiAgICBcImZvcmVpZ25vYmplY3RcIixcbiAgICBcImRlc2NcIixcbiAgICBcInRpdGxlXCIsXG5dKTtcbnZhciByZU5hbWVFbmQgPSAvXFxzfFxcLy87XG52YXIgUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlcihjYnMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8qKiBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIGxhc3QgZXZlbnQuICovXG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIC8qKiBUaGUgZW5kIGluZGV4IG9mIHRoZSBsYXN0IGV2ZW50LiAqL1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlIHRoZSBzdGFydCBpbmRleCBvZiB0aGUgY3VycmVudCBvcGVuIHRhZyxcbiAgICAgICAgICogc28gd2UgY2FuIHVwZGF0ZSB0aGUgc3RhcnQgaW5kZXggZm9yIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW5UYWdTdGFydCA9IDA7XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlibmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlidmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYnMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgIC8qKiBUaGUgaW5kZXggb2YgdGhlIGxhc3Qgd3JpdHRlbiBidWZmZXIuIFVzZWQgd2hlbiByZXN1bWluZyBhZnRlciBhIGBwYXVzZSgpYC4gKi9cbiAgICAgICAgdGhpcy53cml0ZUluZGV4ID0gMDtcbiAgICAgICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBwYXJzZXIgaGFzIGZpbmlzaGVkIHJ1bm5pbmcgLyBgLmVuZGAgaGFzIGJlZW4gY2FsbGVkLiAqL1xuICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2JzID0gY2JzICE9PSBudWxsICYmIGNicyAhPT0gdm9pZCAwID8gY2JzIDoge307XG4gICAgICAgIHRoaXMuaHRtbE1vZGUgPSAhdGhpcy5vcHRpb25zLnhtbE1vZGU7XG4gICAgICAgIHRoaXMubG93ZXJDYXNlVGFnTmFtZXMgPSAoX2EgPSBvcHRpb25zLmxvd2VyQ2FzZVRhZ3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuaHRtbE1vZGU7XG4gICAgICAgIHRoaXMubG93ZXJDYXNlQXR0cmlidXRlTmFtZXMgPVxuICAgICAgICAgICAgKF9iID0gb3B0aW9ucy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5odG1sTW9kZTtcbiAgICAgICAgdGhpcy5yZWNvZ25pemVTZWxmQ2xvc2luZyA9XG4gICAgICAgICAgICAoX2MgPSBvcHRpb25zLnJlY29nbml6ZVNlbGZDbG9zaW5nKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAhdGhpcy5odG1sTW9kZTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSBuZXcgKChfZCA9IG9wdGlvbnMuVG9rZW5pemVyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBUb2tlbml6ZXJfanNfMS5kZWZhdWx0KSh0aGlzLm9wdGlvbnMsIHRoaXMpO1xuICAgICAgICB0aGlzLmZvcmVpZ25Db250ZXh0ID0gWyF0aGlzLmh0bWxNb2RlXTtcbiAgICAgICAgKF9mID0gKF9lID0gdGhpcy5jYnMpLm9ucGFyc2VyaW5pdCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UsIHRoaXMpO1xuICAgIH1cbiAgICAvLyBUb2tlbml6ZXIgZXZlbnQgaGFuZGxlcnNcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbnRleHQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZEluZGV4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXggLSAxO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZGF0YSk7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IGVuZEluZGV4O1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUub250ZXh0ZW50aXR5ID0gZnVuY3Rpb24gKGNwLCBlbmRJbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXggLSAxO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgKDAsIGRlY29kZV9qc18xLmZyb21Db2RlUG9pbnQpKGNwKSk7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IGVuZEluZGV4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHRhZyBpcyBhIHZvaWQgZWxlbWVudC4gT3ZlcnJpZGUgdGhpcyBpZiB5b3Ugd2FudFxuICAgICAqIHRvIHNwZWNpZnkgeW91ciBvd24gYWRkaXRpb25hbCB2b2lkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuaXNWb2lkRWxlbWVudCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0bWxNb2RlICYmIHZvaWRFbGVtZW50cy5oYXMobmFtZSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbm9wZW50YWduYW1lID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5sb3dlckNhc2VUYWdOYW1lcykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRPcGVuVGFnKG5hbWUpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5lbWl0T3BlblRhZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5vcGVuVGFnU3RhcnQgPSB0aGlzLnN0YXJ0SW5kZXg7XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IG5hbWU7XG4gICAgICAgIHZhciBpbXBsaWVzQ2xvc2UgPSB0aGlzLmh0bWxNb2RlICYmIG9wZW5JbXBsaWVzQ2xvc2UuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoaW1wbGllc0Nsb3NlKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiAwICYmIGltcGxpZXNDbG9zZS5oYXModGhpcy5zdGFja1swXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25jbG9zZXRhZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1ZvaWRFbGVtZW50KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnVuc2hpZnQobmFtZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5odG1sTW9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JlaWduQ29udGV4dEVsZW1lbnRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmVpZ25Db250ZXh0LnVuc2hpZnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGh0bWxJbnRlZ3JhdGlvbkVsZW1lbnRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmVpZ25Db250ZXh0LnVuc2hpZnQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNicykub25vcGVudGFnbmFtZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIG5hbWUpO1xuICAgICAgICBpZiAodGhpcy5jYnMub25vcGVudGFnKVxuICAgICAgICAgICAgdGhpcy5hdHRyaWJzID0ge307XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmVuZE9wZW5UYWcgPSBmdW5jdGlvbiAoaXNJbXBsaWVkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IHRoaXMub3BlblRhZ1N0YXJ0O1xuICAgICAgICBpZiAodGhpcy5hdHRyaWJzKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25vcGVudGFnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcy50YWduYW1lLCB0aGlzLmF0dHJpYnMsIGlzSW1wbGllZCk7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNicy5vbmNsb3NldGFnICYmIHRoaXMuaXNWb2lkRWxlbWVudCh0aGlzLnRhZ25hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmNsb3NldGFnKHRoaXMudGFnbmFtZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YWduYW1lID0gXCJcIjtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLm9ub3BlbnRhZ2VuZCA9IGZ1bmN0aW9uIChlbmRJbmRleCkge1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIHRoaXMuZW5kT3BlblRhZyhmYWxzZSk7XG4gICAgICAgIC8vIFNldCBgc3RhcnRJbmRleGAgZm9yIG5leHQgbm9kZVxuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBlbmRJbmRleCArIDE7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmNsb3NldGFnID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXRTbGljZShzdGFydCwgZW5kSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5sb3dlckNhc2VUYWdOYW1lcykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5odG1sTW9kZSAmJlxuICAgICAgICAgICAgKGZvcmVpZ25Db250ZXh0RWxlbWVudHMuaGFzKG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgaHRtbEludGVncmF0aW9uRWxlbWVudHMuaGFzKG5hbWUpKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JlaWduQ29udGV4dC5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1ZvaWRFbGVtZW50KG5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5zdGFjay5pbmRleE9mKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDw9IHBvczsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Uga25vdyB0aGUgc3RhY2sgaGFzIHN1ZmZpY2llbnQgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbmNsb3NldGFnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZWxlbWVudCwgaW5kZXggIT09IHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5odG1sTW9kZSAmJiBuYW1lID09PSBcInBcIikge1xuICAgICAgICAgICAgICAgIC8vIEltcGxpY2l0IG9wZW4gYmVmb3JlIGNsb3NlXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0T3BlblRhZyhcInBcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUN1cnJlbnRUYWcodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5odG1sTW9kZSAmJiBuYW1lID09PSBcImJyXCIpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IHVzZSBgZW1pdE9wZW5UYWdgIGZvciBpbXBsaWNpdCBvcGVuLCBhcyBgYnJgIHdvdWxkIGJlIGltcGxpY2l0bHkgY2xvc2VkLlxuICAgICAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYnMpLm9ub3BlbnRhZ25hbWUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCBcImJyXCIpO1xuICAgICAgICAgICAgKF9mID0gKF9lID0gdGhpcy5jYnMpLm9ub3BlbnRhZykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UsIFwiYnJcIiwge30sIHRydWUpO1xuICAgICAgICAgICAgKF9oID0gKF9nID0gdGhpcy5jYnMpLm9uY2xvc2V0YWcpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5jYWxsKF9nLCBcImJyXCIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgYHN0YXJ0SW5kZXhgIGZvciBuZXh0IG5vZGVcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUub25zZWxmY2xvc2luZ3RhZyA9IGZ1bmN0aW9uIChlbmRJbmRleCkge1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIGlmICh0aGlzLnJlY29nbml6ZVNlbGZDbG9zaW5nIHx8IHRoaXMuZm9yZWlnbkNvbnRleHRbMF0pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDdXJyZW50VGFnKGZhbHNlKTtcbiAgICAgICAgICAgIC8vIFNldCBgc3RhcnRJbmRleGAgZm9yIG5leHQgbm9kZVxuICAgICAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWdub3JlIHRoZSBmYWN0IHRoYXQgdGhlIHRhZyBpcyBzZWxmLWNsb3NpbmcuXG4gICAgICAgICAgICB0aGlzLm9ub3BlbnRhZ2VuZChlbmRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuY2xvc2VDdXJyZW50VGFnID0gZnVuY3Rpb24gKGlzT3BlbkltcGxpZWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRhZ25hbWU7XG4gICAgICAgIHRoaXMuZW5kT3BlblRhZyhpc09wZW5JbXBsaWVkKTtcbiAgICAgICAgLy8gU2VsZi1jbG9zaW5nIHRhZ3Mgd2lsbCBiZSBvbiB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAgICBpZiAodGhpcy5zdGFja1swXSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9wZW5pbmcgdGFnIGlzbid0IGltcGxpZWQsIHRoZSBjbG9zaW5nIHRhZyBoYXMgdG8gYmUgaW1wbGllZC5cbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbmNsb3NldGFnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgbmFtZSwgIWlzT3BlbkltcGxpZWQpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYm5hbWUgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZEluZGV4KSB7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IHN0YXJ0O1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIGVuZEluZGV4KTtcbiAgICAgICAgdGhpcy5hdHRyaWJuYW1lID0gdGhpcy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lc1xuICAgICAgICAgICAgPyBuYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIDogbmFtZTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLm9uYXR0cmliZGF0YSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kSW5kZXgpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ2YWx1ZSArPSB0aGlzLmdldFNsaWNlKHN0YXJ0LCBlbmRJbmRleCk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYmVudGl0eSA9IGZ1bmN0aW9uIChjcCkge1xuICAgICAgICB0aGlzLmF0dHJpYnZhbHVlICs9ICgwLCBkZWNvZGVfanNfMS5mcm9tQ29kZVBvaW50KShjcCk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYmVuZCA9IGZ1bmN0aW9uIChxdW90ZSwgZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25hdHRyaWJ1dGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aGlzLmF0dHJpYm5hbWUsIHRoaXMuYXR0cmlidmFsdWUsIHF1b3RlID09PSBUb2tlbml6ZXJfanNfMS5RdW90ZVR5cGUuRG91YmxlXG4gICAgICAgICAgICA/ICdcIidcbiAgICAgICAgICAgIDogcXVvdGUgPT09IFRva2VuaXplcl9qc18xLlF1b3RlVHlwZS5TaW5nbGVcbiAgICAgICAgICAgICAgICA/IFwiJ1wiXG4gICAgICAgICAgICAgICAgOiBxdW90ZSA9PT0gVG9rZW5pemVyX2pzXzEuUXVvdGVUeXBlLk5vVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlicyAmJlxuICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnMsIHRoaXMuYXR0cmlibmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlic1t0aGlzLmF0dHJpYm5hbWVdID0gdGhpcy5hdHRyaWJ2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dHJpYnZhbHVlID0gXCJcIjtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuZ2V0SW5zdHJ1Y3Rpb25OYW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHZhbHVlLnNlYXJjaChyZU5hbWVFbmQpO1xuICAgICAgICB2YXIgbmFtZSA9IGluZGV4IDwgMCA/IHZhbHVlIDogdmFsdWUuc3Vic3RyKDAsIGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMubG93ZXJDYXNlVGFnTmFtZXMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIGVuZEluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0SW5zdHJ1Y3Rpb25OYW1lKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKFwiIVwiLmNvbmNhdChuYW1lKSwgXCIhXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGBzdGFydEluZGV4YCBmb3IgbmV4dCBub2RlXG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IGVuZEluZGV4ICsgMTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIGVuZEluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0SW5zdHJ1Y3Rpb25OYW1lKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKFwiP1wiLmNvbmNhdChuYW1lKSwgXCI/XCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGBzdGFydEluZGV4YCBmb3IgbmV4dCBub2RlXG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IGVuZEluZGV4ICsgMTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLm9uY29tbWVudCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kSW5kZXgsIG9mZnNldCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uY29tbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIGVuZEluZGV4IC0gb2Zmc2V0KSk7XG4gICAgICAgIChfZCA9IChfYyA9IHRoaXMuY2JzKS5vbmNvbW1lbnRlbmQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKTtcbiAgICAgICAgLy8gU2V0IGBzdGFydEluZGV4YCBmb3IgbmV4dCBub2RlXG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IGVuZEluZGV4ICsgMTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLm9uY2RhdGEgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZEluZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIGVuZEluZGV4IC0gb2Zmc2V0KTtcbiAgICAgICAgaWYgKCF0aGlzLmh0bWxNb2RlIHx8IHRoaXMub3B0aW9ucy5yZWNvZ25pemVDREFUQSkge1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uY2RhdGFzdGFydCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYnMpLm9udGV4dCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIHZhbHVlKTtcbiAgICAgICAgICAgIChfZiA9IChfZSA9IHRoaXMuY2JzKS5vbmNkYXRhZW5kKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoX2ggPSAoX2cgPSB0aGlzLmNicykub25jb21tZW50KSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guY2FsbChfZywgXCJbQ0RBVEFbXCIuY29uY2F0KHZhbHVlLCBcIl1dXCIpKTtcbiAgICAgICAgICAgIChfayA9IChfaiA9IHRoaXMuY2JzKS5vbmNvbW1lbnRlbmQpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5jYWxsKF9qKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgYHN0YXJ0SW5kZXhgIGZvciBuZXh0IG5vZGVcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUub25lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmNicy5vbmNsb3NldGFnKSB7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGVuZCBpbmRleCBmb3IgYWxsIHJlbWFpbmluZyB0YWdzXG4gICAgICAgICAgICB0aGlzLmVuZEluZGV4ID0gdGhpcy5zdGFydEluZGV4O1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuc3RhY2subGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub25jbG9zZXRhZyh0aGlzLnN0YWNrW2luZGV4XSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uZW5kKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHBhcnNlciB0byBhIGJsYW5rIHN0YXRlLCByZWFkeSB0byBwYXJzZSBhIG5ldyBIVE1MIGRvY3VtZW50XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25yZXNldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB0aGlzLnRva2VuaXplci5yZXNldCgpO1xuICAgICAgICB0aGlzLnRhZ25hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYnMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSAwO1xuICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNicykub25wYXJzZXJpbml0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdGhpcyk7XG4gICAgICAgIHRoaXMuYnVmZmVycy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmZvcmVpZ25Db250ZXh0Lmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHQudW5zaGlmdCghdGhpcy5odG1sTW9kZSk7XG4gICAgICAgIHRoaXMuYnVmZmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy53cml0ZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBwYXJzZXIsIHRoZW4gcGFyc2VzIGEgY29tcGxldGUgZG9jdW1lbnQgYW5kXG4gICAgICogcHVzaGVzIGl0IHRvIHRoZSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgRG9jdW1lbnQgdG8gcGFyc2UuXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbXBsZXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLmVuZChkYXRhKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuZ2V0U2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB3aGlsZSAoc3RhcnQgLSB0aGlzLmJ1ZmZlck9mZnNldCA+PSB0aGlzLmJ1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNsaWNlID0gdGhpcy5idWZmZXJzWzBdLnNsaWNlKHN0YXJ0IC0gdGhpcy5idWZmZXJPZmZzZXQsIGVuZCAtIHRoaXMuYnVmZmVyT2Zmc2V0KTtcbiAgICAgICAgd2hpbGUgKGVuZCAtIHRoaXMuYnVmZmVyT2Zmc2V0ID4gdGhpcy5idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zaGlmdEJ1ZmZlcigpO1xuICAgICAgICAgICAgc2xpY2UgKz0gdGhpcy5idWZmZXJzWzBdLnNsaWNlKDAsIGVuZCAtIHRoaXMuYnVmZmVyT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnNoaWZ0QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCArPSB0aGlzLmJ1ZmZlcnNbMF0ubGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlSW5kZXgtLTtcbiAgICAgICAgdGhpcy5idWZmZXJzLnNoaWZ0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBjaHVuayBvZiBkYXRhIGFuZCBjYWxscyB0aGUgY29ycmVzcG9uZGluZyBjYWxsYmFja3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2h1bmsgQ2h1bmsgdG8gcGFyc2UuXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBuZXcgRXJyb3IoXCIud3JpdGUoKSBhZnRlciBkb25lIVwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICBpZiAodGhpcy50b2tlbml6ZXIucnVubmluZykge1xuICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZW5kIG9mIHRoZSBidWZmZXIgYW5kIGNsZWFycyB0aGUgc3RhY2ssIGNhbGxzIG9uZW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNodW5rIE9wdGlvbmFsIGZpbmFsIGNodW5rIHRvIHBhcnNlLlxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25lcnJvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG5ldyBFcnJvcihcIi5lbmQoKSBhZnRlciBkb25lIVwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rKVxuICAgICAgICAgICAgdGhpcy53cml0ZShjaHVuayk7XG4gICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRva2VuaXplci5lbmQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhdXNlcyBwYXJzaW5nLiBUaGUgcGFyc2VyIHdvbid0IGVtaXQgZXZlbnRzIHVudGlsIGByZXN1bWVgIGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRva2VuaXplci5wYXVzZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzdW1lcyBwYXJzaW5nIGFmdGVyIGBwYXVzZWAgd2FzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIucmVzdW1lKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLnRva2VuaXplci5ydW5uaW5nICYmXG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXggPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuaXplci53cml0ZSh0aGlzLmJ1ZmZlcnNbdGhpcy53cml0ZUluZGV4KytdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbmRlZClcbiAgICAgICAgICAgIHRoaXMudG9rZW5pemVyLmVuZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgYHdyaXRlYCwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNodW5rIENodW5rIHRvIHBhcnNlLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMud3JpdGUoY2h1bmspO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgYGVuZGAsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaHVuayBPcHRpb25hbCBmaW5hbCBjaHVuayB0byBwYXJzZS5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmVuZChjaHVuayk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VyO1xufSgpKTtcbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/lib/Parser.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/htmlparser2/lib/Tokenizer.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/htmlparser2/lib/Tokenizer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QuoteType = void 0;\nvar decode_js_1 = __webpack_require__(/*! entities/lib/decode.js */ \"(rsc)/../../../node_modules/entities/lib/decode.js\");\nvar CharCodes;\n(function (CharCodes) {\n    CharCodes[CharCodes[\"Tab\"] = 9] = \"Tab\";\n    CharCodes[CharCodes[\"NewLine\"] = 10] = \"NewLine\";\n    CharCodes[CharCodes[\"FormFeed\"] = 12] = \"FormFeed\";\n    CharCodes[CharCodes[\"CarriageReturn\"] = 13] = \"CarriageReturn\";\n    CharCodes[CharCodes[\"Space\"] = 32] = \"Space\";\n    CharCodes[CharCodes[\"ExclamationMark\"] = 33] = \"ExclamationMark\";\n    CharCodes[CharCodes[\"Number\"] = 35] = \"Number\";\n    CharCodes[CharCodes[\"Amp\"] = 38] = \"Amp\";\n    CharCodes[CharCodes[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    CharCodes[CharCodes[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    CharCodes[CharCodes[\"Dash\"] = 45] = \"Dash\";\n    CharCodes[CharCodes[\"Slash\"] = 47] = \"Slash\";\n    CharCodes[CharCodes[\"Zero\"] = 48] = \"Zero\";\n    CharCodes[CharCodes[\"Nine\"] = 57] = \"Nine\";\n    CharCodes[CharCodes[\"Semi\"] = 59] = \"Semi\";\n    CharCodes[CharCodes[\"Lt\"] = 60] = \"Lt\";\n    CharCodes[CharCodes[\"Eq\"] = 61] = \"Eq\";\n    CharCodes[CharCodes[\"Gt\"] = 62] = \"Gt\";\n    CharCodes[CharCodes[\"Questionmark\"] = 63] = \"Questionmark\";\n    CharCodes[CharCodes[\"UpperA\"] = 65] = \"UpperA\";\n    CharCodes[CharCodes[\"LowerA\"] = 97] = \"LowerA\";\n    CharCodes[CharCodes[\"UpperF\"] = 70] = \"UpperF\";\n    CharCodes[CharCodes[\"LowerF\"] = 102] = \"LowerF\";\n    CharCodes[CharCodes[\"UpperZ\"] = 90] = \"UpperZ\";\n    CharCodes[CharCodes[\"LowerZ\"] = 122] = \"LowerZ\";\n    CharCodes[CharCodes[\"LowerX\"] = 120] = \"LowerX\";\n    CharCodes[CharCodes[\"OpeningSquareBracket\"] = 91] = \"OpeningSquareBracket\";\n})(CharCodes || (CharCodes = {}));\n/** All the states the tokenizer can be in. */\nvar State;\n(function (State) {\n    State[State[\"Text\"] = 1] = \"Text\";\n    State[State[\"BeforeTagName\"] = 2] = \"BeforeTagName\";\n    State[State[\"InTagName\"] = 3] = \"InTagName\";\n    State[State[\"InSelfClosingTag\"] = 4] = \"InSelfClosingTag\";\n    State[State[\"BeforeClosingTagName\"] = 5] = \"BeforeClosingTagName\";\n    State[State[\"InClosingTagName\"] = 6] = \"InClosingTagName\";\n    State[State[\"AfterClosingTagName\"] = 7] = \"AfterClosingTagName\";\n    // Attributes\n    State[State[\"BeforeAttributeName\"] = 8] = \"BeforeAttributeName\";\n    State[State[\"InAttributeName\"] = 9] = \"InAttributeName\";\n    State[State[\"AfterAttributeName\"] = 10] = \"AfterAttributeName\";\n    State[State[\"BeforeAttributeValue\"] = 11] = \"BeforeAttributeValue\";\n    State[State[\"InAttributeValueDq\"] = 12] = \"InAttributeValueDq\";\n    State[State[\"InAttributeValueSq\"] = 13] = \"InAttributeValueSq\";\n    State[State[\"InAttributeValueNq\"] = 14] = \"InAttributeValueNq\";\n    // Declarations\n    State[State[\"BeforeDeclaration\"] = 15] = \"BeforeDeclaration\";\n    State[State[\"InDeclaration\"] = 16] = \"InDeclaration\";\n    // Processing instructions\n    State[State[\"InProcessingInstruction\"] = 17] = \"InProcessingInstruction\";\n    // Comments & CDATA\n    State[State[\"BeforeComment\"] = 18] = \"BeforeComment\";\n    State[State[\"CDATASequence\"] = 19] = \"CDATASequence\";\n    State[State[\"InSpecialComment\"] = 20] = \"InSpecialComment\";\n    State[State[\"InCommentLike\"] = 21] = \"InCommentLike\";\n    // Special tags\n    State[State[\"BeforeSpecialS\"] = 22] = \"BeforeSpecialS\";\n    State[State[\"BeforeSpecialT\"] = 23] = \"BeforeSpecialT\";\n    State[State[\"SpecialStartSequence\"] = 24] = \"SpecialStartSequence\";\n    State[State[\"InSpecialTag\"] = 25] = \"InSpecialTag\";\n    State[State[\"InEntity\"] = 26] = \"InEntity\";\n})(State || (State = {}));\nfunction isWhitespace(c) {\n    return (c === CharCodes.Space ||\n        c === CharCodes.NewLine ||\n        c === CharCodes.Tab ||\n        c === CharCodes.FormFeed ||\n        c === CharCodes.CarriageReturn);\n}\nfunction isEndOfTagSection(c) {\n    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);\n}\nfunction isASCIIAlpha(c) {\n    return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||\n        (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));\n}\nvar QuoteType;\n(function (QuoteType) {\n    QuoteType[QuoteType[\"NoValue\"] = 0] = \"NoValue\";\n    QuoteType[QuoteType[\"Unquoted\"] = 1] = \"Unquoted\";\n    QuoteType[QuoteType[\"Single\"] = 2] = \"Single\";\n    QuoteType[QuoteType[\"Double\"] = 3] = \"Double\";\n})(QuoteType || (exports.QuoteType = QuoteType = {}));\n/**\n * Sequences used to match longer strings.\n *\n * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End\n * sequences with an increased offset.\n */\nvar Sequences = {\n    Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]), // CDATA[\n    CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]), // ]]>\n    CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]), // `-->`\n    ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]), // `</script`\n    StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]), // `</style`\n    TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`\n    TextareaEnd: new Uint8Array([\n        0x3c, 0x2f, 0x74, 0x65, 0x78, 0x74, 0x61, 0x72, 0x65, 0x61,\n    ]), // `</textarea`\n};\nvar Tokenizer = /** @class */ (function () {\n    function Tokenizer(_a, cbs) {\n        var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;\n        var _this = this;\n        this.cbs = cbs;\n        /** The current state the tokenizer is in. */\n        this.state = State.Text;\n        /** The read buffer. */\n        this.buffer = \"\";\n        /** The beginning of the section that is currently being read. */\n        this.sectionStart = 0;\n        /** The index within the buffer that we are currently looking at. */\n        this.index = 0;\n        /** The start of the last entity. */\n        this.entityStart = 0;\n        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n        this.baseState = State.Text;\n        /** For special parsing behavior inside of script and style tags. */\n        this.isSpecial = false;\n        /** Indicates whether the tokenizer has been paused. */\n        this.running = true;\n        /** The offset of the current buffer. */\n        this.offset = 0;\n        this.currentSequence = undefined;\n        this.sequenceIndex = 0;\n        this.xmlMode = xmlMode;\n        this.decodeEntities = decodeEntities;\n        this.entityDecoder = new decode_js_1.EntityDecoder(xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree, function (cp, consumed) { return _this.emitCodePoint(cp, consumed); });\n    }\n    Tokenizer.prototype.reset = function () {\n        this.state = State.Text;\n        this.buffer = \"\";\n        this.sectionStart = 0;\n        this.index = 0;\n        this.baseState = State.Text;\n        this.currentSequence = undefined;\n        this.running = true;\n        this.offset = 0;\n    };\n    Tokenizer.prototype.write = function (chunk) {\n        this.offset += this.buffer.length;\n        this.buffer = chunk;\n        this.parse();\n    };\n    Tokenizer.prototype.end = function () {\n        if (this.running)\n            this.finish();\n    };\n    Tokenizer.prototype.pause = function () {\n        this.running = false;\n    };\n    Tokenizer.prototype.resume = function () {\n        this.running = true;\n        if (this.index < this.buffer.length + this.offset) {\n            this.parse();\n        }\n    };\n    Tokenizer.prototype.stateText = function (c) {\n        if (c === CharCodes.Lt ||\n            (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {\n            if (this.index > this.sectionStart) {\n                this.cbs.ontext(this.sectionStart, this.index);\n            }\n            this.state = State.BeforeTagName;\n            this.sectionStart = this.index;\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    };\n    Tokenizer.prototype.stateSpecialStartSequence = function (c) {\n        var isEnd = this.sequenceIndex === this.currentSequence.length;\n        var isMatch = isEnd\n            ? // If we are at the end of the sequence, make sure the tag name has ended\n                isEndOfTagSection(c)\n            : // Otherwise, do a case-insensitive comparison\n                (c | 0x20) === this.currentSequence[this.sequenceIndex];\n        if (!isMatch) {\n            this.isSpecial = false;\n        }\n        else if (!isEnd) {\n            this.sequenceIndex++;\n            return;\n        }\n        this.sequenceIndex = 0;\n        this.state = State.InTagName;\n        this.stateInTagName(c);\n    };\n    /** Look for an end tag. For <title> tags, also decode entities. */\n    Tokenizer.prototype.stateInSpecialTag = function (c) {\n        if (this.sequenceIndex === this.currentSequence.length) {\n            if (c === CharCodes.Gt || isWhitespace(c)) {\n                var endOfText = this.index - this.currentSequence.length;\n                if (this.sectionStart < endOfText) {\n                    // Spoof the index so that reported locations match up.\n                    var actualIndex = this.index;\n                    this.index = endOfText;\n                    this.cbs.ontext(this.sectionStart, endOfText);\n                    this.index = actualIndex;\n                }\n                this.isSpecial = false;\n                this.sectionStart = endOfText + 2; // Skip over the `</`\n                this.stateInClosingTagName(c);\n                return; // We are done; skip the rest of the function.\n            }\n            this.sequenceIndex = 0;\n        }\n        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {\n            this.sequenceIndex += 1;\n        }\n        else if (this.sequenceIndex === 0) {\n            if (this.currentSequence === Sequences.TitleEnd) {\n                // We have to parse entities in <title> tags.\n                if (this.decodeEntities && c === CharCodes.Amp) {\n                    this.startEntity();\n                }\n            }\n            else if (this.fastForwardTo(CharCodes.Lt)) {\n                // Outside of <title> tags, we can fast-forward.\n                this.sequenceIndex = 1;\n            }\n        }\n        else {\n            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.\n            this.sequenceIndex = Number(c === CharCodes.Lt);\n        }\n    };\n    Tokenizer.prototype.stateCDATASequence = function (c) {\n        if (c === Sequences.Cdata[this.sequenceIndex]) {\n            if (++this.sequenceIndex === Sequences.Cdata.length) {\n                this.state = State.InCommentLike;\n                this.currentSequence = Sequences.CdataEnd;\n                this.sequenceIndex = 0;\n                this.sectionStart = this.index + 1;\n            }\n        }\n        else {\n            this.sequenceIndex = 0;\n            this.state = State.InDeclaration;\n            this.stateInDeclaration(c); // Reconsume the character\n        }\n    };\n    /**\n     * When we wait for one specific character, we can speed things up\n     * by skipping through the buffer until we find it.\n     *\n     * @returns Whether the character was found.\n     */\n    Tokenizer.prototype.fastForwardTo = function (c) {\n        while (++this.index < this.buffer.length + this.offset) {\n            if (this.buffer.charCodeAt(this.index - this.offset) === c) {\n                return true;\n            }\n        }\n        /*\n         * We increment the index at the end of the `parse` loop,\n         * so set it to `buffer.length - 1` here.\n         *\n         * TODO: Refactor `parse` to increment index before calling states.\n         */\n        this.index = this.buffer.length + this.offset - 1;\n        return false;\n    };\n    /**\n     * Comments and CDATA end with `-->` and `]]>`.\n     *\n     * Their common qualities are:\n     * - Their end sequences have a distinct character they start with.\n     * - That character is then repeated, so we have to check multiple repeats.\n     * - All characters but the start character of the sequence can be skipped.\n     */\n    Tokenizer.prototype.stateInCommentLike = function (c) {\n        if (c === this.currentSequence[this.sequenceIndex]) {\n            if (++this.sequenceIndex === this.currentSequence.length) {\n                if (this.currentSequence === Sequences.CdataEnd) {\n                    this.cbs.oncdata(this.sectionStart, this.index, 2);\n                }\n                else {\n                    this.cbs.oncomment(this.sectionStart, this.index, 2);\n                }\n                this.sequenceIndex = 0;\n                this.sectionStart = this.index + 1;\n                this.state = State.Text;\n            }\n        }\n        else if (this.sequenceIndex === 0) {\n            // Fast-forward to the first character of the sequence\n            if (this.fastForwardTo(this.currentSequence[0])) {\n                this.sequenceIndex = 1;\n            }\n        }\n        else if (c !== this.currentSequence[this.sequenceIndex - 1]) {\n            // Allow long sequences, eg. --->, ]]]>\n            this.sequenceIndex = 0;\n        }\n    };\n    /**\n     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.\n     *\n     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).\n     * We allow anything that wouldn't end the tag.\n     */\n    Tokenizer.prototype.isTagStartChar = function (c) {\n        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);\n    };\n    Tokenizer.prototype.startSpecial = function (sequence, offset) {\n        this.isSpecial = true;\n        this.currentSequence = sequence;\n        this.sequenceIndex = offset;\n        this.state = State.SpecialStartSequence;\n    };\n    Tokenizer.prototype.stateBeforeTagName = function (c) {\n        if (c === CharCodes.ExclamationMark) {\n            this.state = State.BeforeDeclaration;\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.Questionmark) {\n            this.state = State.InProcessingInstruction;\n            this.sectionStart = this.index + 1;\n        }\n        else if (this.isTagStartChar(c)) {\n            var lower = c | 0x20;\n            this.sectionStart = this.index;\n            if (this.xmlMode) {\n                this.state = State.InTagName;\n            }\n            else if (lower === Sequences.ScriptEnd[2]) {\n                this.state = State.BeforeSpecialS;\n            }\n            else if (lower === Sequences.TitleEnd[2]) {\n                this.state = State.BeforeSpecialT;\n            }\n            else {\n                this.state = State.InTagName;\n            }\n        }\n        else if (c === CharCodes.Slash) {\n            this.state = State.BeforeClosingTagName;\n        }\n        else {\n            this.state = State.Text;\n            this.stateText(c);\n        }\n    };\n    Tokenizer.prototype.stateInTagName = function (c) {\n        if (isEndOfTagSection(c)) {\n            this.cbs.onopentagname(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n    };\n    Tokenizer.prototype.stateBeforeClosingTagName = function (c) {\n        if (isWhitespace(c)) {\n            // Ignore\n        }\n        else if (c === CharCodes.Gt) {\n            this.state = State.Text;\n        }\n        else {\n            this.state = this.isTagStartChar(c)\n                ? State.InClosingTagName\n                : State.InSpecialComment;\n            this.sectionStart = this.index;\n        }\n    };\n    Tokenizer.prototype.stateInClosingTagName = function (c) {\n        if (c === CharCodes.Gt || isWhitespace(c)) {\n            this.cbs.onclosetag(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.AfterClosingTagName;\n            this.stateAfterClosingTagName(c);\n        }\n    };\n    Tokenizer.prototype.stateAfterClosingTagName = function (c) {\n        // Skip everything until \">\"\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    };\n    Tokenizer.prototype.stateBeforeAttributeName = function (c) {\n        if (c === CharCodes.Gt) {\n            this.cbs.onopentagend(this.index);\n            if (this.isSpecial) {\n                this.state = State.InSpecialTag;\n                this.sequenceIndex = 0;\n            }\n            else {\n                this.state = State.Text;\n            }\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.Slash) {\n            this.state = State.InSelfClosingTag;\n        }\n        else if (!isWhitespace(c)) {\n            this.state = State.InAttributeName;\n            this.sectionStart = this.index;\n        }\n    };\n    Tokenizer.prototype.stateInSelfClosingTag = function (c) {\n        if (c === CharCodes.Gt) {\n            this.cbs.onselfclosingtag(this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n            this.isSpecial = false; // Reset special state, in case of self-closing special tags\n        }\n        else if (!isWhitespace(c)) {\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n    };\n    Tokenizer.prototype.stateInAttributeName = function (c) {\n        if (c === CharCodes.Eq || isEndOfTagSection(c)) {\n            this.cbs.onattribname(this.sectionStart, this.index);\n            this.sectionStart = this.index;\n            this.state = State.AfterAttributeName;\n            this.stateAfterAttributeName(c);\n        }\n    };\n    Tokenizer.prototype.stateAfterAttributeName = function (c) {\n        if (c === CharCodes.Eq) {\n            this.state = State.BeforeAttributeValue;\n        }\n        else if (c === CharCodes.Slash || c === CharCodes.Gt) {\n            this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);\n            this.sectionStart = -1;\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n        else if (!isWhitespace(c)) {\n            this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);\n            this.state = State.InAttributeName;\n            this.sectionStart = this.index;\n        }\n    };\n    Tokenizer.prototype.stateBeforeAttributeValue = function (c) {\n        if (c === CharCodes.DoubleQuote) {\n            this.state = State.InAttributeValueDq;\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.SingleQuote) {\n            this.state = State.InAttributeValueSq;\n            this.sectionStart = this.index + 1;\n        }\n        else if (!isWhitespace(c)) {\n            this.sectionStart = this.index;\n            this.state = State.InAttributeValueNq;\n            this.stateInAttributeValueNoQuotes(c); // Reconsume token\n        }\n    };\n    Tokenizer.prototype.handleInAttributeValue = function (c, quote) {\n        if (c === quote ||\n            (!this.decodeEntities && this.fastForwardTo(quote))) {\n            this.cbs.onattribdata(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.cbs.onattribend(quote === CharCodes.DoubleQuote\n                ? QuoteType.Double\n                : QuoteType.Single, this.index + 1);\n            this.state = State.BeforeAttributeName;\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    };\n    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {\n        this.handleInAttributeValue(c, CharCodes.DoubleQuote);\n    };\n    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {\n        this.handleInAttributeValue(c, CharCodes.SingleQuote);\n    };\n    Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {\n        if (isWhitespace(c) || c === CharCodes.Gt) {\n            this.cbs.onattribdata(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.cbs.onattribend(QuoteType.Unquoted, this.index);\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    };\n    Tokenizer.prototype.stateBeforeDeclaration = function (c) {\n        if (c === CharCodes.OpeningSquareBracket) {\n            this.state = State.CDATASequence;\n            this.sequenceIndex = 0;\n        }\n        else {\n            this.state =\n                c === CharCodes.Dash\n                    ? State.BeforeComment\n                    : State.InDeclaration;\n        }\n    };\n    Tokenizer.prototype.stateInDeclaration = function (c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.ondeclaration(this.sectionStart, this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    };\n    Tokenizer.prototype.stateInProcessingInstruction = function (c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.onprocessinginstruction(this.sectionStart, this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    };\n    Tokenizer.prototype.stateBeforeComment = function (c) {\n        if (c === CharCodes.Dash) {\n            this.state = State.InCommentLike;\n            this.currentSequence = Sequences.CommentEnd;\n            // Allow short comments (eg. <!-->)\n            this.sequenceIndex = 2;\n            this.sectionStart = this.index + 1;\n        }\n        else {\n            this.state = State.InDeclaration;\n        }\n    };\n    Tokenizer.prototype.stateInSpecialComment = function (c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.oncomment(this.sectionStart, this.index, 0);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    };\n    Tokenizer.prototype.stateBeforeSpecialS = function (c) {\n        var lower = c | 0x20;\n        if (lower === Sequences.ScriptEnd[3]) {\n            this.startSpecial(Sequences.ScriptEnd, 4);\n        }\n        else if (lower === Sequences.StyleEnd[3]) {\n            this.startSpecial(Sequences.StyleEnd, 4);\n        }\n        else {\n            this.state = State.InTagName;\n            this.stateInTagName(c); // Consume the token again\n        }\n    };\n    Tokenizer.prototype.stateBeforeSpecialT = function (c) {\n        var lower = c | 0x20;\n        if (lower === Sequences.TitleEnd[3]) {\n            this.startSpecial(Sequences.TitleEnd, 4);\n        }\n        else if (lower === Sequences.TextareaEnd[3]) {\n            this.startSpecial(Sequences.TextareaEnd, 4);\n        }\n        else {\n            this.state = State.InTagName;\n            this.stateInTagName(c); // Consume the token again\n        }\n    };\n    Tokenizer.prototype.startEntity = function () {\n        this.baseState = this.state;\n        this.state = State.InEntity;\n        this.entityStart = this.index;\n        this.entityDecoder.startEntity(this.xmlMode\n            ? decode_js_1.DecodingMode.Strict\n            : this.baseState === State.Text ||\n                this.baseState === State.InSpecialTag\n                ? decode_js_1.DecodingMode.Legacy\n                : decode_js_1.DecodingMode.Attribute);\n    };\n    Tokenizer.prototype.stateInEntity = function () {\n        var length = this.entityDecoder.write(this.buffer, this.index - this.offset);\n        // If `length` is positive, we are done with the entity.\n        if (length >= 0) {\n            this.state = this.baseState;\n            if (length === 0) {\n                this.index = this.entityStart;\n            }\n        }\n        else {\n            // Mark buffer as consumed.\n            this.index = this.offset + this.buffer.length - 1;\n        }\n    };\n    /**\n     * Remove data that has already been consumed from the buffer.\n     */\n    Tokenizer.prototype.cleanup = function () {\n        // If we are inside of text or attributes, emit what we already have.\n        if (this.running && this.sectionStart !== this.index) {\n            if (this.state === State.Text ||\n                (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {\n                this.cbs.ontext(this.sectionStart, this.index);\n                this.sectionStart = this.index;\n            }\n            else if (this.state === State.InAttributeValueDq ||\n                this.state === State.InAttributeValueSq ||\n                this.state === State.InAttributeValueNq) {\n                this.cbs.onattribdata(this.sectionStart, this.index);\n                this.sectionStart = this.index;\n            }\n        }\n    };\n    Tokenizer.prototype.shouldContinue = function () {\n        return this.index < this.buffer.length + this.offset && this.running;\n    };\n    /**\n     * Iterates through the buffer, calling the function corresponding to the current state.\n     *\n     * States that are more likely to be hit are higher up, as a performance improvement.\n     */\n    Tokenizer.prototype.parse = function () {\n        while (this.shouldContinue()) {\n            var c = this.buffer.charCodeAt(this.index - this.offset);\n            switch (this.state) {\n                case State.Text: {\n                    this.stateText(c);\n                    break;\n                }\n                case State.SpecialStartSequence: {\n                    this.stateSpecialStartSequence(c);\n                    break;\n                }\n                case State.InSpecialTag: {\n                    this.stateInSpecialTag(c);\n                    break;\n                }\n                case State.CDATASequence: {\n                    this.stateCDATASequence(c);\n                    break;\n                }\n                case State.InAttributeValueDq: {\n                    this.stateInAttributeValueDoubleQuotes(c);\n                    break;\n                }\n                case State.InAttributeName: {\n                    this.stateInAttributeName(c);\n                    break;\n                }\n                case State.InCommentLike: {\n                    this.stateInCommentLike(c);\n                    break;\n                }\n                case State.InSpecialComment: {\n                    this.stateInSpecialComment(c);\n                    break;\n                }\n                case State.BeforeAttributeName: {\n                    this.stateBeforeAttributeName(c);\n                    break;\n                }\n                case State.InTagName: {\n                    this.stateInTagName(c);\n                    break;\n                }\n                case State.InClosingTagName: {\n                    this.stateInClosingTagName(c);\n                    break;\n                }\n                case State.BeforeTagName: {\n                    this.stateBeforeTagName(c);\n                    break;\n                }\n                case State.AfterAttributeName: {\n                    this.stateAfterAttributeName(c);\n                    break;\n                }\n                case State.InAttributeValueSq: {\n                    this.stateInAttributeValueSingleQuotes(c);\n                    break;\n                }\n                case State.BeforeAttributeValue: {\n                    this.stateBeforeAttributeValue(c);\n                    break;\n                }\n                case State.BeforeClosingTagName: {\n                    this.stateBeforeClosingTagName(c);\n                    break;\n                }\n                case State.AfterClosingTagName: {\n                    this.stateAfterClosingTagName(c);\n                    break;\n                }\n                case State.BeforeSpecialS: {\n                    this.stateBeforeSpecialS(c);\n                    break;\n                }\n                case State.BeforeSpecialT: {\n                    this.stateBeforeSpecialT(c);\n                    break;\n                }\n                case State.InAttributeValueNq: {\n                    this.stateInAttributeValueNoQuotes(c);\n                    break;\n                }\n                case State.InSelfClosingTag: {\n                    this.stateInSelfClosingTag(c);\n                    break;\n                }\n                case State.InDeclaration: {\n                    this.stateInDeclaration(c);\n                    break;\n                }\n                case State.BeforeDeclaration: {\n                    this.stateBeforeDeclaration(c);\n                    break;\n                }\n                case State.BeforeComment: {\n                    this.stateBeforeComment(c);\n                    break;\n                }\n                case State.InProcessingInstruction: {\n                    this.stateInProcessingInstruction(c);\n                    break;\n                }\n                case State.InEntity: {\n                    this.stateInEntity();\n                    break;\n                }\n            }\n            this.index++;\n        }\n        this.cleanup();\n    };\n    Tokenizer.prototype.finish = function () {\n        if (this.state === State.InEntity) {\n            this.entityDecoder.end();\n            this.state = this.baseState;\n        }\n        this.handleTrailingData();\n        this.cbs.onend();\n    };\n    /** Handle any trailing data. */\n    Tokenizer.prototype.handleTrailingData = function () {\n        var endIndex = this.buffer.length + this.offset;\n        // If there is no remaining data, we are done.\n        if (this.sectionStart >= endIndex) {\n            return;\n        }\n        if (this.state === State.InCommentLike) {\n            if (this.currentSequence === Sequences.CdataEnd) {\n                this.cbs.oncdata(this.sectionStart, endIndex, 0);\n            }\n            else {\n                this.cbs.oncomment(this.sectionStart, endIndex, 0);\n            }\n        }\n        else if (this.state === State.InTagName ||\n            this.state === State.BeforeAttributeName ||\n            this.state === State.BeforeAttributeValue ||\n            this.state === State.AfterAttributeName ||\n            this.state === State.InAttributeName ||\n            this.state === State.InAttributeValueSq ||\n            this.state === State.InAttributeValueDq ||\n            this.state === State.InAttributeValueNq ||\n            this.state === State.InClosingTagName) {\n            /*\n             * If we are currently in an opening or closing tag, us not calling the\n             * respective callback signals that the tag should be ignored.\n             */\n        }\n        else {\n            this.cbs.ontext(this.sectionStart, endIndex);\n        }\n    };\n    Tokenizer.prototype.emitCodePoint = function (cp, consumed) {\n        if (this.baseState !== State.Text &&\n            this.baseState !== State.InSpecialTag) {\n            if (this.sectionStart < this.entityStart) {\n                this.cbs.onattribdata(this.sectionStart, this.entityStart);\n            }\n            this.sectionStart = this.entityStart + consumed;\n            this.index = this.sectionStart - 1;\n            this.cbs.onattribentity(cp);\n        }\n        else {\n            if (this.sectionStart < this.entityStart) {\n                this.cbs.ontext(this.sectionStart, this.entityStart);\n            }\n            this.sectionStart = this.entityStart + consumed;\n            this.index = this.sectionStart - 1;\n            this.cbs.ontextentity(cp, this.sectionStart);\n        }\n    };\n    return Tokenizer;\n}());\nexports[\"default\"] = Tokenizer;\n//# sourceMappingURL=Tokenizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9Ub2tlbml6ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGtCQUFrQixtQkFBTyxDQUFDLGtGQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0IsaUJBQWlCLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKLDJDQUEyQztBQUNsTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL0BvcnVrL2h1Yi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL1Rva2VuaXplci5qcz8yMDQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdW90ZVR5cGUgPSB2b2lkIDA7XG52YXIgZGVjb2RlX2pzXzEgPSByZXF1aXJlKFwiZW50aXRpZXMvbGliL2RlY29kZS5qc1wiKTtcbnZhciBDaGFyQ29kZXM7XG4oZnVuY3Rpb24gKENoYXJDb2Rlcykge1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJUYWJcIl0gPSA5XSA9IFwiVGFiXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIk5ld0xpbmVcIl0gPSAxMF0gPSBcIk5ld0xpbmVcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiRm9ybUZlZWRcIl0gPSAxMl0gPSBcIkZvcm1GZWVkXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkNhcnJpYWdlUmV0dXJuXCJdID0gMTNdID0gXCJDYXJyaWFnZVJldHVyblwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJTcGFjZVwiXSA9IDMyXSA9IFwiU3BhY2VcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiRXhjbGFtYXRpb25NYXJrXCJdID0gMzNdID0gXCJFeGNsYW1hdGlvbk1hcmtcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTnVtYmVyXCJdID0gMzVdID0gXCJOdW1iZXJcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiQW1wXCJdID0gMzhdID0gXCJBbXBcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiU2luZ2xlUXVvdGVcIl0gPSAzOV0gPSBcIlNpbmdsZVF1b3RlXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkRvdWJsZVF1b3RlXCJdID0gMzRdID0gXCJEb3VibGVRdW90ZVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJEYXNoXCJdID0gNDVdID0gXCJEYXNoXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlNsYXNoXCJdID0gNDddID0gXCJTbGFzaFwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJaZXJvXCJdID0gNDhdID0gXCJaZXJvXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIk5pbmVcIl0gPSA1N10gPSBcIk5pbmVcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiU2VtaVwiXSA9IDU5XSA9IFwiU2VtaVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJMdFwiXSA9IDYwXSA9IFwiTHRcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiRXFcIl0gPSA2MV0gPSBcIkVxXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkd0XCJdID0gNjJdID0gXCJHdFwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJRdWVzdGlvbm1hcmtcIl0gPSA2M10gPSBcIlF1ZXN0aW9ubWFya1wiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJVcHBlckFcIl0gPSA2NV0gPSBcIlVwcGVyQVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJMb3dlckFcIl0gPSA5N10gPSBcIkxvd2VyQVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJVcHBlckZcIl0gPSA3MF0gPSBcIlVwcGVyRlwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJMb3dlckZcIl0gPSAxMDJdID0gXCJMb3dlckZcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiVXBwZXJaXCJdID0gOTBdID0gXCJVcHBlclpcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTG93ZXJaXCJdID0gMTIyXSA9IFwiTG93ZXJaXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkxvd2VyWFwiXSA9IDEyMF0gPSBcIkxvd2VyWFwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJPcGVuaW5nU3F1YXJlQnJhY2tldFwiXSA9IDkxXSA9IFwiT3BlbmluZ1NxdWFyZUJyYWNrZXRcIjtcbn0pKENoYXJDb2RlcyB8fCAoQ2hhckNvZGVzID0ge30pKTtcbi8qKiBBbGwgdGhlIHN0YXRlcyB0aGUgdG9rZW5pemVyIGNhbiBiZSBpbi4gKi9cbnZhciBTdGF0ZTtcbihmdW5jdGlvbiAoU3RhdGUpIHtcbiAgICBTdGF0ZVtTdGF0ZVtcIlRleHRcIl0gPSAxXSA9IFwiVGV4dFwiO1xuICAgIFN0YXRlW1N0YXRlW1wiQmVmb3JlVGFnTmFtZVwiXSA9IDJdID0gXCJCZWZvcmVUYWdOYW1lXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJblRhZ05hbWVcIl0gPSAzXSA9IFwiSW5UYWdOYW1lXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJblNlbGZDbG9zaW5nVGFnXCJdID0gNF0gPSBcIkluU2VsZkNsb3NpbmdUYWdcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZUNsb3NpbmdUYWdOYW1lXCJdID0gNV0gPSBcIkJlZm9yZUNsb3NpbmdUYWdOYW1lXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJbkNsb3NpbmdUYWdOYW1lXCJdID0gNl0gPSBcIkluQ2xvc2luZ1RhZ05hbWVcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkFmdGVyQ2xvc2luZ1RhZ05hbWVcIl0gPSA3XSA9IFwiQWZ0ZXJDbG9zaW5nVGFnTmFtZVwiO1xuICAgIC8vIEF0dHJpYnV0ZXNcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZUF0dHJpYnV0ZU5hbWVcIl0gPSA4XSA9IFwiQmVmb3JlQXR0cmlidXRlTmFtZVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5BdHRyaWJ1dGVOYW1lXCJdID0gOV0gPSBcIkluQXR0cmlidXRlTmFtZVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiQWZ0ZXJBdHRyaWJ1dGVOYW1lXCJdID0gMTBdID0gXCJBZnRlckF0dHJpYnV0ZU5hbWVcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZUF0dHJpYnV0ZVZhbHVlXCJdID0gMTFdID0gXCJCZWZvcmVBdHRyaWJ1dGVWYWx1ZVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiSW5BdHRyaWJ1dGVWYWx1ZURxXCJdID0gMTJdID0gXCJJbkF0dHJpYnV0ZVZhbHVlRHFcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluQXR0cmlidXRlVmFsdWVTcVwiXSA9IDEzXSA9IFwiSW5BdHRyaWJ1dGVWYWx1ZVNxXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJbkF0dHJpYnV0ZVZhbHVlTnFcIl0gPSAxNF0gPSBcIkluQXR0cmlidXRlVmFsdWVOcVwiO1xuICAgIC8vIERlY2xhcmF0aW9uc1xuICAgIFN0YXRlW1N0YXRlW1wiQmVmb3JlRGVjbGFyYXRpb25cIl0gPSAxNV0gPSBcIkJlZm9yZURlY2xhcmF0aW9uXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJbkRlY2xhcmF0aW9uXCJdID0gMTZdID0gXCJJbkRlY2xhcmF0aW9uXCI7XG4gICAgLy8gUHJvY2Vzc2luZyBpbnN0cnVjdGlvbnNcbiAgICBTdGF0ZVtTdGF0ZVtcIkluUHJvY2Vzc2luZ0luc3RydWN0aW9uXCJdID0gMTddID0gXCJJblByb2Nlc3NpbmdJbnN0cnVjdGlvblwiO1xuICAgIC8vIENvbW1lbnRzICYgQ0RBVEFcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZUNvbW1lbnRcIl0gPSAxOF0gPSBcIkJlZm9yZUNvbW1lbnRcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkNEQVRBU2VxdWVuY2VcIl0gPSAxOV0gPSBcIkNEQVRBU2VxdWVuY2VcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluU3BlY2lhbENvbW1lbnRcIl0gPSAyMF0gPSBcIkluU3BlY2lhbENvbW1lbnRcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluQ29tbWVudExpa2VcIl0gPSAyMV0gPSBcIkluQ29tbWVudExpa2VcIjtcbiAgICAvLyBTcGVjaWFsIHRhZ3NcbiAgICBTdGF0ZVtTdGF0ZVtcIkJlZm9yZVNwZWNpYWxTXCJdID0gMjJdID0gXCJCZWZvcmVTcGVjaWFsU1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiQmVmb3JlU3BlY2lhbFRcIl0gPSAyM10gPSBcIkJlZm9yZVNwZWNpYWxUXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJTcGVjaWFsU3RhcnRTZXF1ZW5jZVwiXSA9IDI0XSA9IFwiU3BlY2lhbFN0YXJ0U2VxdWVuY2VcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIkluU3BlY2lhbFRhZ1wiXSA9IDI1XSA9IFwiSW5TcGVjaWFsVGFnXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJbkVudGl0eVwiXSA9IDI2XSA9IFwiSW5FbnRpdHlcIjtcbn0pKFN0YXRlIHx8IChTdGF0ZSA9IHt9KSk7XG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoYykge1xuICAgIHJldHVybiAoYyA9PT0gQ2hhckNvZGVzLlNwYWNlIHx8XG4gICAgICAgIGMgPT09IENoYXJDb2Rlcy5OZXdMaW5lIHx8XG4gICAgICAgIGMgPT09IENoYXJDb2Rlcy5UYWIgfHxcbiAgICAgICAgYyA9PT0gQ2hhckNvZGVzLkZvcm1GZWVkIHx8XG4gICAgICAgIGMgPT09IENoYXJDb2Rlcy5DYXJyaWFnZVJldHVybik7XG59XG5mdW5jdGlvbiBpc0VuZE9mVGFnU2VjdGlvbihjKSB7XG4gICAgcmV0dXJuIGMgPT09IENoYXJDb2Rlcy5TbGFzaCB8fCBjID09PSBDaGFyQ29kZXMuR3QgfHwgaXNXaGl0ZXNwYWNlKGMpO1xufVxuZnVuY3Rpb24gaXNBU0NJSUFscGhhKGMpIHtcbiAgICByZXR1cm4gKChjID49IENoYXJDb2Rlcy5Mb3dlckEgJiYgYyA8PSBDaGFyQ29kZXMuTG93ZXJaKSB8fFxuICAgICAgICAoYyA+PSBDaGFyQ29kZXMuVXBwZXJBICYmIGMgPD0gQ2hhckNvZGVzLlVwcGVyWikpO1xufVxudmFyIFF1b3RlVHlwZTtcbihmdW5jdGlvbiAoUXVvdGVUeXBlKSB7XG4gICAgUXVvdGVUeXBlW1F1b3RlVHlwZVtcIk5vVmFsdWVcIl0gPSAwXSA9IFwiTm9WYWx1ZVwiO1xuICAgIFF1b3RlVHlwZVtRdW90ZVR5cGVbXCJVbnF1b3RlZFwiXSA9IDFdID0gXCJVbnF1b3RlZFwiO1xuICAgIFF1b3RlVHlwZVtRdW90ZVR5cGVbXCJTaW5nbGVcIl0gPSAyXSA9IFwiU2luZ2xlXCI7XG4gICAgUXVvdGVUeXBlW1F1b3RlVHlwZVtcIkRvdWJsZVwiXSA9IDNdID0gXCJEb3VibGVcIjtcbn0pKFF1b3RlVHlwZSB8fCAoZXhwb3J0cy5RdW90ZVR5cGUgPSBRdW90ZVR5cGUgPSB7fSkpO1xuLyoqXG4gKiBTZXF1ZW5jZXMgdXNlZCB0byBtYXRjaCBsb25nZXIgc3RyaW5ncy5cbiAqXG4gKiBXZSBkb24ndCBoYXZlIGBTY3JpcHRgLCBgU3R5bGVgLCBvciBgVGl0bGVgIGhlcmUuIEluc3RlYWQsIHdlIHJlLXVzZSB0aGUgKkVuZFxuICogc2VxdWVuY2VzIHdpdGggYW4gaW5jcmVhc2VkIG9mZnNldC5cbiAqL1xudmFyIFNlcXVlbmNlcyA9IHtcbiAgICBDZGF0YTogbmV3IFVpbnQ4QXJyYXkoWzB4NDMsIDB4NDQsIDB4NDEsIDB4NTQsIDB4NDEsIDB4NWJdKSwgLy8gQ0RBVEFbXG4gICAgQ2RhdGFFbmQ6IG5ldyBVaW50OEFycmF5KFsweDVkLCAweDVkLCAweDNlXSksIC8vIF1dPlxuICAgIENvbW1lbnRFbmQ6IG5ldyBVaW50OEFycmF5KFsweDJkLCAweDJkLCAweDNlXSksIC8vIGAtLT5gXG4gICAgU2NyaXB0RW5kOiBuZXcgVWludDhBcnJheShbMHgzYywgMHgyZiwgMHg3MywgMHg2MywgMHg3MiwgMHg2OSwgMHg3MCwgMHg3NF0pLCAvLyBgPC9zY3JpcHRgXG4gICAgU3R5bGVFbmQ6IG5ldyBVaW50OEFycmF5KFsweDNjLCAweDJmLCAweDczLCAweDc0LCAweDc5LCAweDZjLCAweDY1XSksIC8vIGA8L3N0eWxlYFxuICAgIFRpdGxlRW5kOiBuZXcgVWludDhBcnJheShbMHgzYywgMHgyZiwgMHg3NCwgMHg2OSwgMHg3NCwgMHg2YywgMHg2NV0pLCAvLyBgPC90aXRsZWBcbiAgICBUZXh0YXJlYUVuZDogbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDNjLCAweDJmLCAweDc0LCAweDY1LCAweDc4LCAweDc0LCAweDYxLCAweDcyLCAweDY1LCAweDYxLFxuICAgIF0pLCAvLyBgPC90ZXh0YXJlYWBcbn07XG52YXIgVG9rZW5pemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRva2VuaXplcihfYSwgY2JzKSB7XG4gICAgICAgIHZhciBfYiA9IF9hLnhtbE1vZGUsIHhtbE1vZGUgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgX2MgPSBfYS5kZWNvZGVFbnRpdGllcywgZGVjb2RlRW50aXRpZXMgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNicyA9IGNicztcbiAgICAgICAgLyoqIFRoZSBjdXJyZW50IHN0YXRlIHRoZSB0b2tlbml6ZXIgaXMgaW4uICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICAvKiogVGhlIHJlYWQgYnVmZmVyLiAqL1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIC8qKiBUaGUgYmVnaW5uaW5nIG9mIHRoZSBzZWN0aW9uIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHJlYWQuICovXG4gICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gMDtcbiAgICAgICAgLyoqIFRoZSBpbmRleCB3aXRoaW4gdGhlIGJ1ZmZlciB0aGF0IHdlIGFyZSBjdXJyZW50bHkgbG9va2luZyBhdC4gKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIC8qKiBUaGUgc3RhcnQgb2YgdGhlIGxhc3QgZW50aXR5LiAqL1xuICAgICAgICB0aGlzLmVudGl0eVN0YXJ0ID0gMDtcbiAgICAgICAgLyoqIFNvbWUgYmVoYXZpb3IsIGVnLiB3aGVuIGRlY29kaW5nIGVudGl0aWVzLCBpcyBkb25lIHdoaWxlIHdlIGFyZSBpbiBhbm90aGVyIHN0YXRlLiBUaGlzIGtlZXBzIHRyYWNrIG9mIHRoZSBvdGhlciBzdGF0ZSB0eXBlLiAqL1xuICAgICAgICB0aGlzLmJhc2VTdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgIC8qKiBGb3Igc3BlY2lhbCBwYXJzaW5nIGJlaGF2aW9yIGluc2lkZSBvZiBzY3JpcHQgYW5kIHN0eWxlIHRhZ3MuICovXG4gICAgICAgIHRoaXMuaXNTcGVjaWFsID0gZmFsc2U7XG4gICAgICAgIC8qKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdG9rZW5pemVyIGhhcyBiZWVuIHBhdXNlZC4gKi9cbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgLyoqIFRoZSBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyLiAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFNlcXVlbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnhtbE1vZGUgPSB4bWxNb2RlO1xuICAgICAgICB0aGlzLmRlY29kZUVudGl0aWVzID0gZGVjb2RlRW50aXRpZXM7XG4gICAgICAgIHRoaXMuZW50aXR5RGVjb2RlciA9IG5ldyBkZWNvZGVfanNfMS5FbnRpdHlEZWNvZGVyKHhtbE1vZGUgPyBkZWNvZGVfanNfMS54bWxEZWNvZGVUcmVlIDogZGVjb2RlX2pzXzEuaHRtbERlY29kZVRyZWUsIGZ1bmN0aW9uIChjcCwgY29uc3VtZWQpIHsgcmV0dXJuIF90aGlzLmVtaXRDb2RlUG9pbnQoY3AsIGNvbnN1bWVkKTsgfSk7XG4gICAgfVxuICAgIFRva2VuaXplci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5UZXh0O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYmFzZVN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGNodW5rO1xuICAgICAgICB0aGlzLnBhcnNlKCk7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZylcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVUZXh0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5MdCB8fFxuICAgICAgICAgICAgKCF0aGlzLmRlY29kZUVudGl0aWVzICYmIHRoaXMuZmFzdEZvcndhcmRUbyhDaGFyQ29kZXMuTHQpKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPiB0aGlzLnNlY3Rpb25TdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9udGV4dCh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlVGFnTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRlY29kZUVudGl0aWVzICYmIGMgPT09IENoYXJDb2Rlcy5BbXApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRFbnRpdHkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZVNwZWNpYWxTdGFydFNlcXVlbmNlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGlzRW5kID0gdGhpcy5zZXF1ZW5jZUluZGV4ID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5sZW5ndGg7XG4gICAgICAgIHZhciBpc01hdGNoID0gaXNFbmRcbiAgICAgICAgICAgID8gLy8gSWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCBtYWtlIHN1cmUgdGhlIHRhZyBuYW1lIGhhcyBlbmRlZFxuICAgICAgICAgICAgICAgIGlzRW5kT2ZUYWdTZWN0aW9uKGMpXG4gICAgICAgICAgICA6IC8vIE90aGVyd2lzZSwgZG8gYSBjYXNlLWluc2Vuc2l0aXZlIGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAoYyB8IDB4MjApID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZVt0aGlzLnNlcXVlbmNlSW5kZXhdO1xuICAgICAgICBpZiAoIWlzTWF0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTcGVjaWFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzRW5kKSB7XG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5UYWdOYW1lO1xuICAgICAgICB0aGlzLnN0YXRlSW5UYWdOYW1lKGMpO1xuICAgIH07XG4gICAgLyoqIExvb2sgZm9yIGFuIGVuZCB0YWcuIEZvciA8dGl0bGU+IHRhZ3MsIGFsc28gZGVjb2RlIGVudGl0aWVzLiAqL1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJblNwZWNpYWxUYWcgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAodGhpcy5zZXF1ZW5jZUluZGV4ID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QgfHwgaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZE9mVGV4dCA9IHRoaXMuaW5kZXggLSB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VjdGlvblN0YXJ0IDwgZW5kT2ZUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwb29mIHRoZSBpbmRleCBzbyB0aGF0IHJlcG9ydGVkIGxvY2F0aW9ucyBtYXRjaCB1cC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdHVhbEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGVuZE9mVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCBlbmRPZlRleHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gYWN0dWFsSW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaXNTcGVjaWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSBlbmRPZlRleHQgKyAyOyAvLyBTa2lwIG92ZXIgdGhlIGA8L2BcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5DbG9zaW5nVGFnTmFtZShjKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFdlIGFyZSBkb25lOyBza2lwIHRoZSByZXN0IG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjIHwgMHgyMCkgPT09IHRoaXMuY3VycmVudFNlcXVlbmNlW3RoaXMuc2VxdWVuY2VJbmRleF0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2VxdWVuY2VJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNlcXVlbmNlID09PSBTZXF1ZW5jZXMuVGl0bGVFbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIHBhcnNlIGVudGl0aWVzIGluIDx0aXRsZT4gdGFncy5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVFbnRpdGllcyAmJiBjID09PSBDaGFyQ29kZXMuQW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRFbnRpdHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZhc3RGb3J3YXJkVG8oQ2hhckNvZGVzLkx0KSkge1xuICAgICAgICAgICAgICAgIC8vIE91dHNpZGUgb2YgPHRpdGxlPiB0YWdzLCB3ZSBjYW4gZmFzdC1mb3J3YXJkLlxuICAgICAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBzZWUgYSBgPGAsIHNldCB0aGUgc2VxdWVuY2UgaW5kZXggdG8gMTsgdXNlZnVsIGZvciBlZy4gYDw8L3NjcmlwdD5gLlxuICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gTnVtYmVyKGMgPT09IENoYXJDb2Rlcy5MdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVDREFUQVNlcXVlbmNlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFNlcXVlbmNlcy5DZGF0YVt0aGlzLnNlcXVlbmNlSW5kZXhdKSB7XG4gICAgICAgICAgICBpZiAoKyt0aGlzLnNlcXVlbmNlSW5kZXggPT09IFNlcXVlbmNlcy5DZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5Db21tZW50TGlrZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IFNlcXVlbmNlcy5DZGF0YUVuZDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluRGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLnN0YXRlSW5EZWNsYXJhdGlvbihjKTsgLy8gUmVjb25zdW1lIHRoZSBjaGFyYWN0ZXJcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSB3YWl0IGZvciBvbmUgc3BlY2lmaWMgY2hhcmFjdGVyLCB3ZSBjYW4gc3BlZWQgdGhpbmdzIHVwXG4gICAgICogYnkgc2tpcHBpbmcgdGhyb3VnaCB0aGUgYnVmZmVyIHVudGlsIHdlIGZpbmQgaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgd2FzIGZvdW5kLlxuICAgICAqL1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZmFzdEZvcndhcmRUbyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHdoaWxlICgrK3RoaXMuaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGggKyB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5pbmRleCAtIHRoaXMub2Zmc2V0KSA9PT0gYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIFdlIGluY3JlbWVudCB0aGUgaW5kZXggYXQgdGhlIGVuZCBvZiB0aGUgYHBhcnNlYCBsb29wLFxuICAgICAgICAgKiBzbyBzZXQgaXQgdG8gYGJ1ZmZlci5sZW5ndGggLSAxYCBoZXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBSZWZhY3RvciBgcGFyc2VgIHRvIGluY3JlbWVudCBpbmRleCBiZWZvcmUgY2FsbGluZyBzdGF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5vZmZzZXQgLSAxO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21tZW50cyBhbmQgQ0RBVEEgZW5kIHdpdGggYC0tPmAgYW5kIGBdXT5gLlxuICAgICAqXG4gICAgICogVGhlaXIgY29tbW9uIHF1YWxpdGllcyBhcmU6XG4gICAgICogLSBUaGVpciBlbmQgc2VxdWVuY2VzIGhhdmUgYSBkaXN0aW5jdCBjaGFyYWN0ZXIgdGhleSBzdGFydCB3aXRoLlxuICAgICAqIC0gVGhhdCBjaGFyYWN0ZXIgaXMgdGhlbiByZXBlYXRlZCwgc28gd2UgaGF2ZSB0byBjaGVjayBtdWx0aXBsZSByZXBlYXRzLlxuICAgICAqIC0gQWxsIGNoYXJhY3RlcnMgYnV0IHRoZSBzdGFydCBjaGFyYWN0ZXIgb2YgdGhlIHNlcXVlbmNlIGNhbiBiZSBza2lwcGVkLlxuICAgICAqL1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbkNvbW1lbnRMaWtlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IHRoaXMuY3VycmVudFNlcXVlbmNlW3RoaXMuc2VxdWVuY2VJbmRleF0pIHtcbiAgICAgICAgICAgIGlmICgrK3RoaXMuc2VxdWVuY2VJbmRleCA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNlcXVlbmNlID09PSBTZXF1ZW5jZXMuQ2RhdGFFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYnMub25jZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCwgMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNicy5vbmNvbW1lbnQodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgsIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zZXF1ZW5jZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBGYXN0LWZvcndhcmQgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIGlmICh0aGlzLmZhc3RGb3J3YXJkVG8odGhpcy5jdXJyZW50U2VxdWVuY2VbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjICE9PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZVt0aGlzLnNlcXVlbmNlSW5kZXggLSAxXSkge1xuICAgICAgICAgICAgLy8gQWxsb3cgbG9uZyBzZXF1ZW5jZXMsIGVnLiAtLS0+LCBdXV0+XG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIVE1MIG9ubHkgYWxsb3dzIEFTQ0lJIGFscGhhIGNoYXJhY3RlcnMgKGEteiBhbmQgQS1aKSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgdGFnIG5hbWUuXG4gICAgICpcbiAgICAgKiBYTUwgYWxsb3dzIGEgbG90IG1vcmUgY2hhcmFjdGVycyBoZXJlIChAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lU3RhcnRDaGFyKS5cbiAgICAgKiBXZSBhbGxvdyBhbnl0aGluZyB0aGF0IHdvdWxkbid0IGVuZCB0aGUgdGFnLlxuICAgICAqL1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuaXNUYWdTdGFydENoYXIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gdGhpcy54bWxNb2RlID8gIWlzRW5kT2ZUYWdTZWN0aW9uKGMpIDogaXNBU0NJSUFscGhhKGMpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGFydFNwZWNpYWwgPSBmdW5jdGlvbiAoc2VxdWVuY2UsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmlzU3BlY2lhbCA9IHRydWU7XG4gICAgICAgIHRoaXMuY3VycmVudFNlcXVlbmNlID0gc2VxdWVuY2U7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNwZWNpYWxTdGFydFNlcXVlbmNlO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZVRhZ05hbWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkV4Y2xhbWF0aW9uTWFyaykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZURlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBDaGFyQ29kZXMuUXVlc3Rpb25tYXJrKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb247XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNUYWdTdGFydENoYXIoYykpIHtcbiAgICAgICAgICAgIHZhciBsb3dlciA9IGMgfCAweDIwO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgaWYgKHRoaXMueG1sTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JblRhZ05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsb3dlciA9PT0gU2VxdWVuY2VzLlNjcmlwdEVuZFsyXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVTcGVjaWFsUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VyID09PSBTZXF1ZW5jZXMuVGl0bGVFbmRbMl0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlU3BlY2lhbFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5UYWdOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IENoYXJDb2Rlcy5TbGFzaCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZUNsb3NpbmdUYWdOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgICAgICB0aGlzLnN0YXRlVGV4dChjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluVGFnTmFtZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChpc0VuZE9mVGFnU2VjdGlvbihjKSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25vcGVudGFnbmFtZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZUF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZUNsb3NpbmdUYWdOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgLy8gSWdub3JlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ2hhckNvZGVzLkd0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmlzVGFnU3RhcnRDaGFyKGMpXG4gICAgICAgICAgICAgICAgPyBTdGF0ZS5JbkNsb3NpbmdUYWdOYW1lXG4gICAgICAgICAgICAgICAgOiBTdGF0ZS5JblNwZWNpYWxDb21tZW50O1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5DbG9zaW5nVGFnTmFtZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QgfHwgaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmNsb3NldGFnKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQWZ0ZXJDbG9zaW5nVGFnTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVBZnRlckNsb3NpbmdUYWdOYW1lKGMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQWZ0ZXJDbG9zaW5nVGFnTmFtZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIFNraXAgZXZlcnl0aGluZyB1bnRpbCBcIj5cIlxuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkd0IHx8IHRoaXMuZmFzdEZvcndhcmRUbyhDaGFyQ29kZXMuR3QpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5HdCkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25vcGVudGFnZW5kKHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTcGVjaWFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluU3BlY2lhbFRhZztcbiAgICAgICAgICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IENoYXJDb2Rlcy5TbGFzaCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluU2VsZkNsb3NpbmdUYWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluU2VsZkNsb3NpbmdUYWcgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkd0KSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbnNlbGZjbG9zaW5ndGFnKHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICAgICAgdGhpcy5pc1NwZWNpYWwgPSBmYWxzZTsgLy8gUmVzZXQgc3BlY2lhbCBzdGF0ZSwgaW4gY2FzZSBvZiBzZWxmLWNsb3Npbmcgc3BlY2lhbCB0YWdzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZUF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuRXEgfHwgaXNFbmRPZlRhZ1NlY3Rpb24oYykpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmlibmFtZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQWZ0ZXJBdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUFmdGVyQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuRXEpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVBdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBDaGFyQ29kZXMuU2xhc2ggfHwgYyA9PT0gQ2hhckNvZGVzLkd0KSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmVuZChRdW90ZVR5cGUuTm9WYWx1ZSwgdGhpcy5zZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CZWZvcmVBdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJpYnV0ZU5hbWUoYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJlbmQoUXVvdGVUeXBlLk5vVmFsdWUsIHRoaXMuc2VjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JbkF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuRG91YmxlUXVvdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlRHE7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IENoYXJDb2Rlcy5TaW5nbGVRdW90ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluQXR0cmlidXRlVmFsdWVTcTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluQXR0cmlidXRlVmFsdWVOcTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVJbkF0dHJpYnV0ZVZhbHVlTm9RdW90ZXMoYyk7IC8vIFJlY29uc3VtZSB0b2tlblxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmhhbmRsZUluQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoYywgcXVvdGUpIHtcbiAgICAgICAgaWYgKGMgPT09IHF1b3RlIHx8XG4gICAgICAgICAgICAoIXRoaXMuZGVjb2RlRW50aXRpZXMgJiYgdGhpcy5mYXN0Rm9yd2FyZFRvKHF1b3RlKSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJlbmQocXVvdGUgPT09IENoYXJDb2Rlcy5Eb3VibGVRdW90ZVxuICAgICAgICAgICAgICAgID8gUXVvdGVUeXBlLkRvdWJsZVxuICAgICAgICAgICAgICAgIDogUXVvdGVUeXBlLlNpbmdsZSwgdGhpcy5pbmRleCArIDEpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJlZm9yZUF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWNvZGVFbnRpdGllcyAmJiBjID09PSBDaGFyQ29kZXMuQW1wKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RW50aXR5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbkF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVzID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVJbkF0dHJpYnV0ZVZhbHVlKGMsIENoYXJDb2Rlcy5Eb3VibGVRdW90ZSk7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5BdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3RlcyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5BdHRyaWJ1dGVWYWx1ZShjLCBDaGFyQ29kZXMuU2luZ2xlUXVvdGUpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluQXR0cmlidXRlVmFsdWVOb1F1b3RlcyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykgfHwgYyA9PT0gQ2hhckNvZGVzLkd0KSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmRhdGEodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKFF1b3RlVHlwZS5VbnF1b3RlZCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQmVmb3JlQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gQ2hhckNvZGVzLkFtcCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydEVudGl0eSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQmVmb3JlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLk9wZW5pbmdTcXVhcmVCcmFja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQ0RBVEFTZXF1ZW5jZTtcbiAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID1cbiAgICAgICAgICAgICAgICBjID09PSBDaGFyQ29kZXMuRGFzaFxuICAgICAgICAgICAgICAgICAgICA/IFN0YXRlLkJlZm9yZUNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgOiBTdGF0ZS5JbkRlY2xhcmF0aW9uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBDaGFyQ29kZXMuR3QgfHwgdGhpcy5mYXN0Rm9yd2FyZFRvKENoYXJDb2Rlcy5HdCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uZGVjbGFyYXRpb24odGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkd0IHx8IHRoaXMuZmFzdEZvcndhcmRUbyhDaGFyQ29kZXMuR3QpKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbih0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuVGV4dDtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVDb21tZW50ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IENoYXJDb2Rlcy5EYXNoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5Db21tZW50TGlrZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlcXVlbmNlID0gU2VxdWVuY2VzLkNvbW1lbnRFbmQ7XG4gICAgICAgICAgICAvLyBBbGxvdyBzaG9ydCBjb21tZW50cyAoZWcuIDwhLS0+KVxuICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMjtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSW5EZWNsYXJhdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluU3BlY2lhbENvbW1lbnQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gQ2hhckNvZGVzLkd0IHx8IHRoaXMuZmFzdEZvcndhcmRUbyhDaGFyQ29kZXMuR3QpKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmNvbW1lbnQodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgsIDApO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlRleHQ7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQmVmb3JlU3BlY2lhbFMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgbG93ZXIgPSBjIHwgMHgyMDtcbiAgICAgICAgaWYgKGxvd2VyID09PSBTZXF1ZW5jZXMuU2NyaXB0RW5kWzNdKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0U3BlY2lhbChTZXF1ZW5jZXMuU2NyaXB0RW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb3dlciA9PT0gU2VxdWVuY2VzLlN0eWxlRW5kWzNdKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0U3BlY2lhbChTZXF1ZW5jZXMuU3R5bGVFbmQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluVGFnTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVJblRhZ05hbWUoYyk7IC8vIENvbnN1bWUgdGhlIHRva2VuIGFnYWluXG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVTcGVjaWFsVCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBsb3dlciA9IGMgfCAweDIwO1xuICAgICAgICBpZiAobG93ZXIgPT09IFNlcXVlbmNlcy5UaXRsZUVuZFszXSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFNwZWNpYWwoU2VxdWVuY2VzLlRpdGxlRW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb3dlciA9PT0gU2VxdWVuY2VzLlRleHRhcmVhRW5kWzNdKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0U3BlY2lhbChTZXF1ZW5jZXMuVGV4dGFyZWFFbmQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluVGFnTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVJblRhZ05hbWUoYyk7IC8vIENvbnN1bWUgdGhlIHRva2VuIGFnYWluXG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhcnRFbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYmFzZVN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkluRW50aXR5O1xuICAgICAgICB0aGlzLmVudGl0eVN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5lbnRpdHlEZWNvZGVyLnN0YXJ0RW50aXR5KHRoaXMueG1sTW9kZVxuICAgICAgICAgICAgPyBkZWNvZGVfanNfMS5EZWNvZGluZ01vZGUuU3RyaWN0XG4gICAgICAgICAgICA6IHRoaXMuYmFzZVN0YXRlID09PSBTdGF0ZS5UZXh0IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlU3RhdGUgPT09IFN0YXRlLkluU3BlY2lhbFRhZ1xuICAgICAgICAgICAgICAgID8gZGVjb2RlX2pzXzEuRGVjb2RpbmdNb2RlLkxlZ2FjeVxuICAgICAgICAgICAgICAgIDogZGVjb2RlX2pzXzEuRGVjb2RpbmdNb2RlLkF0dHJpYnV0ZSk7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5FbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmVudGl0eURlY29kZXIud3JpdGUodGhpcy5idWZmZXIsIHRoaXMuaW5kZXggLSB0aGlzLm9mZnNldCk7XG4gICAgICAgIC8vIElmIGBsZW5ndGhgIGlzIHBvc2l0aXZlLCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBlbnRpdHkuXG4gICAgICAgIGlmIChsZW5ndGggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuYmFzZVN0YXRlO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmVudGl0eVN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTWFyayBidWZmZXIgYXMgY29uc3VtZWQuXG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5vZmZzZXQgKyB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZGF0YSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQgZnJvbSB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGluc2lkZSBvZiB0ZXh0IG9yIGF0dHJpYnV0ZXMsIGVtaXQgd2hhdCB3ZSBhbHJlYWR5IGhhdmUuXG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcgJiYgdGhpcy5zZWN0aW9uU3RhcnQgIT09IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5UZXh0IHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkluU3BlY2lhbFRhZyAmJiB0aGlzLnNlcXVlbmNlSW5kZXggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlRHEgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlU3EgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlTnEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmRhdGEodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zaG91bGRDb250aW51ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGggKyB0aGlzLm9mZnNldCAmJiB0aGlzLnJ1bm5pbmc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBidWZmZXIsIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBTdGF0ZXMgdGhhdCBhcmUgbW9yZSBsaWtlbHkgdG8gYmUgaGl0IGFyZSBoaWdoZXIgdXAsIGFzIGEgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuXG4gICAgICovXG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuc2hvdWxkQ29udGludWUoKSkge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmJ1ZmZlci5jaGFyQ29kZUF0KHRoaXMuaW5kZXggLSB0aGlzLm9mZnNldCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLlRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRleHQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLlNwZWNpYWxTdGFydFNlcXVlbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVTcGVjaWFsU3RhcnRTZXF1ZW5jZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5TcGVjaWFsVGFnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblNwZWNpYWxUYWcoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkNEQVRBU2VxdWVuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUNEQVRBU2VxdWVuY2UoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluQXR0cmlidXRlVmFsdWVEcToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5BdHRyaWJ1dGVWYWx1ZURvdWJsZVF1b3RlcyhjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5BdHRyaWJ1dGVOYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkF0dHJpYnV0ZU5hbWUoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluQ29tbWVudExpa2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQ29tbWVudExpa2UoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluU3BlY2lhbENvbW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluU3BlY2lhbENvbW1lbnQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkJlZm9yZUF0dHJpYnV0ZU5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJpYnV0ZU5hbWUoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluVGFnTmFtZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5UYWdOYW1lKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JbkNsb3NpbmdUYWdOYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkNsb3NpbmdUYWdOYW1lKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5CZWZvcmVUYWdOYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVUYWdOYW1lKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5BZnRlckF0dHJpYnV0ZU5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5BdHRyaWJ1dGVWYWx1ZVNxOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVzKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5CZWZvcmVBdHRyaWJ1dGVWYWx1ZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0cmlidXRlVmFsdWUoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkJlZm9yZUNsb3NpbmdUYWdOYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVDbG9zaW5nVGFnTmFtZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQWZ0ZXJDbG9zaW5nVGFnTmFtZToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJDbG9zaW5nVGFnTmFtZShjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuQmVmb3JlU3BlY2lhbFM6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVNwZWNpYWxTKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5CZWZvcmVTcGVjaWFsVDoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlU3BlY2lhbFQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluQXR0cmlidXRlVmFsdWVOcToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JblNlbGZDbG9zaW5nVGFnOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblNlbGZDbG9zaW5nVGFnKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JbkRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkRlY2xhcmF0aW9uKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5CZWZvcmVEZWNsYXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlRGVjbGFyYXRpb24oYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkJlZm9yZUNvbW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUNvbW1lbnQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkluUHJvY2Vzc2luZ0luc3RydWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblByb2Nlc3NpbmdJbnN0cnVjdGlvbihjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuSW5FbnRpdHk6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluRW50aXR5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuSW5FbnRpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuZW50aXR5RGVjb2Rlci5lbmQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmJhc2VTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZVRyYWlsaW5nRGF0YSgpO1xuICAgICAgICB0aGlzLmNicy5vbmVuZCgpO1xuICAgIH07XG4gICAgLyoqIEhhbmRsZSBhbnkgdHJhaWxpbmcgZGF0YS4gKi9cbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmhhbmRsZVRyYWlsaW5nRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHJlbWFpbmluZyBkYXRhLCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKHRoaXMuc2VjdGlvblN0YXJ0ID49IGVuZEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQ29tbWVudExpa2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9PT0gU2VxdWVuY2VzLkNkYXRhRW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub25jZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgZW5kSW5kZXgsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub25jb21tZW50KHRoaXMuc2VjdGlvblN0YXJ0LCBlbmRJbmRleCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuSW5UYWdOYW1lIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5CZWZvcmVBdHRyaWJ1dGVOYW1lIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5CZWZvcmVBdHRyaWJ1dGVWYWx1ZSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuQWZ0ZXJBdHRyaWJ1dGVOYW1lIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkF0dHJpYnV0ZU5hbWUgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQXR0cmlidXRlVmFsdWVTcSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuSW5BdHRyaWJ1dGVWYWx1ZURxIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JbkF0dHJpYnV0ZVZhbHVlTnEgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkluQ2xvc2luZ1RhZ05hbWUpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBJZiB3ZSBhcmUgY3VycmVudGx5IGluIGFuIG9wZW5pbmcgb3IgY2xvc2luZyB0YWcsIHVzIG5vdCBjYWxsaW5nIHRoZVxuICAgICAgICAgICAgICogcmVzcGVjdGl2ZSBjYWxsYmFjayBzaWduYWxzIHRoYXQgdGhlIHRhZyBzaG91bGQgYmUgaWdub3JlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCBlbmRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZW1pdENvZGVQb2ludCA9IGZ1bmN0aW9uIChjcCwgY29uc3VtZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVN0YXRlICE9PSBTdGF0ZS5UZXh0ICYmXG4gICAgICAgICAgICB0aGlzLmJhc2VTdGF0ZSAhPT0gU3RhdGUuSW5TcGVjaWFsVGFnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWN0aW9uU3RhcnQgPCB0aGlzLmVudGl0eVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJkYXRhKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmVudGl0eVN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5lbnRpdHlTdGFydCArIGNvbnN1bWVkO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc2VjdGlvblN0YXJ0IC0gMTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW50aXR5KGNwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlY3Rpb25TdGFydCA8IHRoaXMuZW50aXR5U3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNicy5vbnRleHQodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuZW50aXR5U3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmVudGl0eVN0YXJ0ICsgY29uc3VtZWQ7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zZWN0aW9uU3RhcnQgLSAxO1xuICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0ZW50aXR5KGNwLCB0aGlzLnNlY3Rpb25TdGFydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUb2tlbml6ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9rZW5pemVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/lib/Tokenizer.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/htmlparser2/lib/index.js":
/*!******************************************************!*\
  !*** ../../../node_modules/htmlparser2/lib/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.QuoteType = exports.Tokenizer = exports.createDomStream = exports.createDocumentStream = exports.parseDOM = exports.parseDocument = exports.DefaultHandler = exports.DomHandler = exports.Parser = void 0;\nvar Parser_js_1 = __webpack_require__(/*! ./Parser.js */ \"(rsc)/../../../node_modules/htmlparser2/lib/Parser.js\");\nvar Parser_js_2 = __webpack_require__(/*! ./Parser.js */ \"(rsc)/../../../node_modules/htmlparser2/lib/Parser.js\");\nObject.defineProperty(exports, \"Parser\", ({ enumerable: true, get: function () { return Parser_js_2.Parser; } }));\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/../../../node_modules/domhandler/lib/index.js\");\nvar domhandler_2 = __webpack_require__(/*! domhandler */ \"(rsc)/../../../node_modules/domhandler/lib/index.js\");\nObject.defineProperty(exports, \"DomHandler\", ({ enumerable: true, get: function () { return domhandler_2.DomHandler; } }));\n// Old name for DomHandler\nObject.defineProperty(exports, \"DefaultHandler\", ({ enumerable: true, get: function () { return domhandler_2.DomHandler; } }));\n// Helper methods\n/**\n * Parses the data, returns the resulting document.\n *\n * @param data The data that should be parsed.\n * @param options Optional options for the parser and DOM handler.\n */\nfunction parseDocument(data, options) {\n    var handler = new domhandler_1.DomHandler(undefined, options);\n    new Parser_js_1.Parser(handler, options).end(data);\n    return handler.root;\n}\nexports.parseDocument = parseDocument;\n/**\n * Parses data, returns an array of the root nodes.\n *\n * Note that the root nodes still have a `Document` node as their parent.\n * Use `parseDocument` to get the `Document` node instead.\n *\n * @param data The data that should be parsed.\n * @param options Optional options for the parser and DOM handler.\n * @deprecated Use `parseDocument` instead.\n */\nfunction parseDOM(data, options) {\n    return parseDocument(data, options).children;\n}\nexports.parseDOM = parseDOM;\n/**\n * Creates a parser instance, with an attached DOM handler.\n *\n * @param callback A callback that will be called once parsing has been completed, with the resulting document.\n * @param options Optional options for the parser and DOM handler.\n * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.\n */\nfunction createDocumentStream(callback, options, elementCallback) {\n    var handler = new domhandler_1.DomHandler(function (error) { return callback(error, handler.root); }, options, elementCallback);\n    return new Parser_js_1.Parser(handler, options);\n}\nexports.createDocumentStream = createDocumentStream;\n/**\n * Creates a parser instance, with an attached DOM handler.\n *\n * @param callback A callback that will be called once parsing has been completed, with an array of root nodes.\n * @param options Optional options for the parser and DOM handler.\n * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.\n * @deprecated Use `createDocumentStream` instead.\n */\nfunction createDomStream(callback, options, elementCallback) {\n    var handler = new domhandler_1.DomHandler(callback, options, elementCallback);\n    return new Parser_js_1.Parser(handler, options);\n}\nexports.createDomStream = createDomStream;\nvar Tokenizer_js_1 = __webpack_require__(/*! ./Tokenizer.js */ \"(rsc)/../../../node_modules/htmlparser2/lib/Tokenizer.js\");\nObject.defineProperty(exports, \"Tokenizer\", ({ enumerable: true, get: function () { return __importDefault(Tokenizer_js_1).default; } }));\nObject.defineProperty(exports, \"QuoteType\", ({ enumerable: true, get: function () { return Tokenizer_js_1.QuoteType; } }));\n/*\n * All of the following exports exist for backwards-compatibility.\n * They should probably be removed eventually.\n */\nexports.ElementType = __importStar(__webpack_require__(/*! domelementtype */ \"(rsc)/../../../node_modules/domelementtype/lib/index.js\"));\nvar domutils_1 = __webpack_require__(/*! domutils */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/index.js\");\nvar domutils_2 = __webpack_require__(/*! domutils */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/index.js\");\nObject.defineProperty(exports, \"getFeed\", ({ enumerable: true, get: function () { return domutils_2.getFeed; } }));\nvar parseFeedDefaultOptions = { xmlMode: true };\n/**\n * Parse a feed.\n *\n * @param feed The feed that should be parsed, as a string.\n * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.\n */\nfunction parseFeed(feed, options) {\n    if (options === void 0) { options = parseFeedDefaultOptions; }\n    return (0, domutils_1.getFeed)(parseDOM(feed, options));\n}\nexports.parseFeed = parseFeed;\nexports.DomUtils = __importStar(__webpack_require__(/*! domutils */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/index.js\"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsdUJBQXVCLEdBQUcsNEJBQTRCLEdBQUcsZ0JBQWdCLEdBQUcscUJBQXFCLEdBQUcsc0JBQXNCLEdBQUcsa0JBQWtCLEdBQUcsY0FBYztBQUN2UixrQkFBa0IsbUJBQU8sQ0FBQywwRUFBYTtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBYTtBQUN2QywwQ0FBeUMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDL0csbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkMsOENBQTZDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3hIO0FBQ0Esa0RBQWlELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHVDQUF1QztBQUN4RztBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDN0MsNkNBQTRDLEVBQUUscUNBQXFDLG1EQUFtRCxFQUFDO0FBQ3ZJLDZDQUE0QyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBZ0I7QUFDM0QsaUJBQWlCLG1CQUFPLENBQUMsNEZBQVU7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsNEZBQVU7QUFDbkMsMkNBQTBDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2hILGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQixnQkFBZ0IsbUJBQU8sQ0FBQyw0RkFBVTtBQUNsRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BvcnVrL2h1Yi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL2luZGV4LmpzPzUzY2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRG9tVXRpbHMgPSBleHBvcnRzLnBhcnNlRmVlZCA9IGV4cG9ydHMuZ2V0RmVlZCA9IGV4cG9ydHMuRWxlbWVudFR5cGUgPSBleHBvcnRzLlF1b3RlVHlwZSA9IGV4cG9ydHMuVG9rZW5pemVyID0gZXhwb3J0cy5jcmVhdGVEb21TdHJlYW0gPSBleHBvcnRzLmNyZWF0ZURvY3VtZW50U3RyZWFtID0gZXhwb3J0cy5wYXJzZURPTSA9IGV4cG9ydHMucGFyc2VEb2N1bWVudCA9IGV4cG9ydHMuRGVmYXVsdEhhbmRsZXIgPSBleHBvcnRzLkRvbUhhbmRsZXIgPSBleHBvcnRzLlBhcnNlciA9IHZvaWQgMDtcbnZhciBQYXJzZXJfanNfMSA9IHJlcXVpcmUoXCIuL1BhcnNlci5qc1wiKTtcbnZhciBQYXJzZXJfanNfMiA9IHJlcXVpcmUoXCIuL1BhcnNlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhcnNlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUGFyc2VyX2pzXzIuUGFyc2VyOyB9IH0pO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xudmFyIGRvbWhhbmRsZXJfMiA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9tSGFuZGxlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9taGFuZGxlcl8yLkRvbUhhbmRsZXI7IH0gfSk7XG4vLyBPbGQgbmFtZSBmb3IgRG9tSGFuZGxlclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVmYXVsdEhhbmRsZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbWhhbmRsZXJfMi5Eb21IYW5kbGVyOyB9IH0pO1xuLy8gSGVscGVyIG1ldGhvZHNcbi8qKlxuICogUGFyc2VzIHRoZSBkYXRhLCByZXR1cm5zIHRoZSByZXN1bHRpbmcgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdGhhdCBzaG91bGQgYmUgcGFyc2VkLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGhhbmRsZXIuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRG9jdW1lbnQoZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciBoYW5kbGVyID0gbmV3IGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyKHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgbmV3IFBhcnNlcl9qc18xLlBhcnNlcihoYW5kbGVyLCBvcHRpb25zKS5lbmQoZGF0YSk7XG4gICAgcmV0dXJuIGhhbmRsZXIucm9vdDtcbn1cbmV4cG9ydHMucGFyc2VEb2N1bWVudCA9IHBhcnNlRG9jdW1lbnQ7XG4vKipcbiAqIFBhcnNlcyBkYXRhLCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByb290IG5vZGVzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgcm9vdCBub2RlcyBzdGlsbCBoYXZlIGEgYERvY3VtZW50YCBub2RlIGFzIHRoZWlyIHBhcmVudC5cbiAqIFVzZSBgcGFyc2VEb2N1bWVudGAgdG8gZ2V0IHRoZSBgRG9jdW1lbnRgIG5vZGUgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0aGF0IHNob3VsZCBiZSBwYXJzZWQuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIGZvciB0aGUgcGFyc2VyIGFuZCBET00gaGFuZGxlci5cbiAqIEBkZXByZWNhdGVkIFVzZSBgcGFyc2VEb2N1bWVudGAgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VET00oZGF0YSwgb3B0aW9ucykge1xuICAgIHJldHVybiBwYXJzZURvY3VtZW50KGRhdGEsIG9wdGlvbnMpLmNoaWxkcmVuO1xufVxuZXhwb3J0cy5wYXJzZURPTSA9IHBhcnNlRE9NO1xuLyoqXG4gKiBDcmVhdGVzIGEgcGFyc2VyIGluc3RhbmNlLCB3aXRoIGFuIGF0dGFjaGVkIERPTSBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayBBIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBwYXJzaW5nIGhhcyBiZWVuIGNvbXBsZXRlZCwgd2l0aCB0aGUgcmVzdWx0aW5nIGRvY3VtZW50LlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGhhbmRsZXIuXG4gKiBAcGFyYW0gZWxlbWVudENhbGxiYWNrIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgZXZlcnkgdGltZSBhIHRhZyBoYXMgYmVlbiBjb21wbGV0ZWQgaW5zaWRlIG9mIHRoZSBET00uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50U3RyZWFtKGNhbGxiYWNrLCBvcHRpb25zLCBlbGVtZW50Q2FsbGJhY2spIHtcbiAgICB2YXIgaGFuZGxlciA9IG5ldyBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcihmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGNhbGxiYWNrKGVycm9yLCBoYW5kbGVyLnJvb3QpOyB9LCBvcHRpb25zLCBlbGVtZW50Q2FsbGJhY2spO1xuICAgIHJldHVybiBuZXcgUGFyc2VyX2pzXzEuUGFyc2VyKGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVEb2N1bWVudFN0cmVhbSA9IGNyZWF0ZURvY3VtZW50U3RyZWFtO1xuLyoqXG4gKiBDcmVhdGVzIGEgcGFyc2VyIGluc3RhbmNlLCB3aXRoIGFuIGF0dGFjaGVkIERPTSBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayBBIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBwYXJzaW5nIGhhcyBiZWVuIGNvbXBsZXRlZCwgd2l0aCBhbiBhcnJheSBvZiByb290IG5vZGVzLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGhhbmRsZXIuXG4gKiBAcGFyYW0gZWxlbWVudENhbGxiYWNrIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgZXZlcnkgdGltZSBhIHRhZyBoYXMgYmVlbiBjb21wbGV0ZWQgaW5zaWRlIG9mIHRoZSBET00uXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGNyZWF0ZURvY3VtZW50U3RyZWFtYCBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEb21TdHJlYW0oY2FsbGJhY2ssIG9wdGlvbnMsIGVsZW1lbnRDYWxsYmFjaykge1xuICAgIHZhciBoYW5kbGVyID0gbmV3IGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyKGNhbGxiYWNrLCBvcHRpb25zLCBlbGVtZW50Q2FsbGJhY2spO1xuICAgIHJldHVybiBuZXcgUGFyc2VyX2pzXzEuUGFyc2VyKGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVEb21TdHJlYW0gPSBjcmVhdGVEb21TdHJlYW07XG52YXIgVG9rZW5pemVyX2pzXzEgPSByZXF1aXJlKFwiLi9Ub2tlbml6ZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb2tlbml6ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChUb2tlbml6ZXJfanNfMSkuZGVmYXVsdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlF1b3RlVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVG9rZW5pemVyX2pzXzEuUXVvdGVUeXBlOyB9IH0pO1xuLypcbiAqIEFsbCBvZiB0aGUgZm9sbG93aW5nIGV4cG9ydHMgZXhpc3QgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LlxuICogVGhleSBzaG91bGQgcHJvYmFibHkgYmUgcmVtb3ZlZCBldmVudHVhbGx5LlxuICovXG5leHBvcnRzLkVsZW1lbnRUeXBlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJkb21lbGVtZW50dHlwZVwiKSk7XG52YXIgZG9tdXRpbHNfMSA9IHJlcXVpcmUoXCJkb211dGlsc1wiKTtcbnZhciBkb211dGlsc18yID0gcmVxdWlyZShcImRvbXV0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RmVlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9tdXRpbHNfMi5nZXRGZWVkOyB9IH0pO1xudmFyIHBhcnNlRmVlZERlZmF1bHRPcHRpb25zID0geyB4bWxNb2RlOiB0cnVlIH07XG4vKipcbiAqIFBhcnNlIGEgZmVlZC5cbiAqXG4gKiBAcGFyYW0gZmVlZCBUaGUgZmVlZCB0aGF0IHNob3VsZCBiZSBwYXJzZWQsIGFzIGEgc3RyaW5nLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWxseSwgb3B0aW9ucyBmb3IgcGFyc2luZy4gV2hlbiB1c2luZyB0aGlzLCB5b3Ugc2hvdWxkIHNldCBgeG1sTW9kZWAgdG8gYHRydWVgLlxuICovXG5mdW5jdGlvbiBwYXJzZUZlZWQoZmVlZCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHBhcnNlRmVlZERlZmF1bHRPcHRpb25zOyB9XG4gICAgcmV0dXJuICgwLCBkb211dGlsc18xLmdldEZlZWQpKHBhcnNlRE9NKGZlZWQsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydHMucGFyc2VGZWVkID0gcGFyc2VGZWVkO1xuZXhwb3J0cy5Eb21VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZG9tdXRpbHNcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/lib/index.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/htmlparser2/node_modules/dom-serializer/lib/foreignNames.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/htmlparser2/node_modules/dom-serializer/lib/foreignNames.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.attributeNames = exports.elementNames = void 0;\nexports.elementNames = new Map([\n    \"altGlyph\",\n    \"altGlyphDef\",\n    \"altGlyphItem\",\n    \"animateColor\",\n    \"animateMotion\",\n    \"animateTransform\",\n    \"clipPath\",\n    \"feBlend\",\n    \"feColorMatrix\",\n    \"feComponentTransfer\",\n    \"feComposite\",\n    \"feConvolveMatrix\",\n    \"feDiffuseLighting\",\n    \"feDisplacementMap\",\n    \"feDistantLight\",\n    \"feDropShadow\",\n    \"feFlood\",\n    \"feFuncA\",\n    \"feFuncB\",\n    \"feFuncG\",\n    \"feFuncR\",\n    \"feGaussianBlur\",\n    \"feImage\",\n    \"feMerge\",\n    \"feMergeNode\",\n    \"feMorphology\",\n    \"feOffset\",\n    \"fePointLight\",\n    \"feSpecularLighting\",\n    \"feSpotLight\",\n    \"feTile\",\n    \"feTurbulence\",\n    \"foreignObject\",\n    \"glyphRef\",\n    \"linearGradient\",\n    \"radialGradient\",\n    \"textPath\",\n].map(function (val) { return [val.toLowerCase(), val]; }));\nexports.attributeNames = new Map([\n    \"definitionURL\",\n    \"attributeName\",\n    \"attributeType\",\n    \"baseFrequency\",\n    \"baseProfile\",\n    \"calcMode\",\n    \"clipPathUnits\",\n    \"diffuseConstant\",\n    \"edgeMode\",\n    \"filterUnits\",\n    \"glyphRef\",\n    \"gradientTransform\",\n    \"gradientUnits\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keyPoints\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"lengthAdjust\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerUnits\",\n    \"markerWidth\",\n    \"maskContentUnits\",\n    \"maskUnits\",\n    \"numOctaves\",\n    \"pathLength\",\n    \"patternContentUnits\",\n    \"patternTransform\",\n    \"patternUnits\",\n    \"pointsAtX\",\n    \"pointsAtY\",\n    \"pointsAtZ\",\n    \"preserveAlpha\",\n    \"preserveAspectRatio\",\n    \"primitiveUnits\",\n    \"refX\",\n    \"refY\",\n    \"repeatCount\",\n    \"repeatDur\",\n    \"requiredExtensions\",\n    \"requiredFeatures\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"spreadMethod\",\n    \"startOffset\",\n    \"stdDeviation\",\n    \"stitchTiles\",\n    \"surfaceScale\",\n    \"systemLanguage\",\n    \"tableValues\",\n    \"targetX\",\n    \"targetY\",\n    \"textLength\",\n    \"viewBox\",\n    \"viewTarget\",\n    \"xChannelSelector\",\n    \"yChannelSelector\",\n    \"zoomAndPan\",\n].map(function (val) { return [val.toLowerCase(), val]; }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9kb20tc2VyaWFsaXplci9saWIvZm9yZWlnbk5hbWVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLG9CQUFvQjtBQUM3QyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDO0FBQ3pELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BvcnVrL2h1Yi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbm9kZV9tb2R1bGVzL2RvbS1zZXJpYWxpemVyL2xpYi9mb3JlaWduTmFtZXMuanM/ZDFkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXR0cmlidXRlTmFtZXMgPSBleHBvcnRzLmVsZW1lbnROYW1lcyA9IHZvaWQgMDtcbmV4cG9ydHMuZWxlbWVudE5hbWVzID0gbmV3IE1hcChbXG4gICAgXCJhbHRHbHlwaFwiLFxuICAgIFwiYWx0R2x5cGhEZWZcIixcbiAgICBcImFsdEdseXBoSXRlbVwiLFxuICAgIFwiYW5pbWF0ZUNvbG9yXCIsXG4gICAgXCJhbmltYXRlTW90aW9uXCIsXG4gICAgXCJhbmltYXRlVHJhbnNmb3JtXCIsXG4gICAgXCJjbGlwUGF0aFwiLFxuICAgIFwiZmVCbGVuZFwiLFxuICAgIFwiZmVDb2xvck1hdHJpeFwiLFxuICAgIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiLFxuICAgIFwiZmVDb21wb3NpdGVcIixcbiAgICBcImZlQ29udm9sdmVNYXRyaXhcIixcbiAgICBcImZlRGlmZnVzZUxpZ2h0aW5nXCIsXG4gICAgXCJmZURpc3BsYWNlbWVudE1hcFwiLFxuICAgIFwiZmVEaXN0YW50TGlnaHRcIixcbiAgICBcImZlRHJvcFNoYWRvd1wiLFxuICAgIFwiZmVGbG9vZFwiLFxuICAgIFwiZmVGdW5jQVwiLFxuICAgIFwiZmVGdW5jQlwiLFxuICAgIFwiZmVGdW5jR1wiLFxuICAgIFwiZmVGdW5jUlwiLFxuICAgIFwiZmVHYXVzc2lhbkJsdXJcIixcbiAgICBcImZlSW1hZ2VcIixcbiAgICBcImZlTWVyZ2VcIixcbiAgICBcImZlTWVyZ2VOb2RlXCIsXG4gICAgXCJmZU1vcnBob2xvZ3lcIixcbiAgICBcImZlT2Zmc2V0XCIsXG4gICAgXCJmZVBvaW50TGlnaHRcIixcbiAgICBcImZlU3BlY3VsYXJMaWdodGluZ1wiLFxuICAgIFwiZmVTcG90TGlnaHRcIixcbiAgICBcImZlVGlsZVwiLFxuICAgIFwiZmVUdXJidWxlbmNlXCIsXG4gICAgXCJmb3JlaWduT2JqZWN0XCIsXG4gICAgXCJnbHlwaFJlZlwiLFxuICAgIFwibGluZWFyR3JhZGllbnRcIixcbiAgICBcInJhZGlhbEdyYWRpZW50XCIsXG4gICAgXCJ0ZXh0UGF0aFwiLFxuXS5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gW3ZhbC50b0xvd2VyQ2FzZSgpLCB2YWxdOyB9KSk7XG5leHBvcnRzLmF0dHJpYnV0ZU5hbWVzID0gbmV3IE1hcChbXG4gICAgXCJkZWZpbml0aW9uVVJMXCIsXG4gICAgXCJhdHRyaWJ1dGVOYW1lXCIsXG4gICAgXCJhdHRyaWJ1dGVUeXBlXCIsXG4gICAgXCJiYXNlRnJlcXVlbmN5XCIsXG4gICAgXCJiYXNlUHJvZmlsZVwiLFxuICAgIFwiY2FsY01vZGVcIixcbiAgICBcImNsaXBQYXRoVW5pdHNcIixcbiAgICBcImRpZmZ1c2VDb25zdGFudFwiLFxuICAgIFwiZWRnZU1vZGVcIixcbiAgICBcImZpbHRlclVuaXRzXCIsXG4gICAgXCJnbHlwaFJlZlwiLFxuICAgIFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgICBcImdyYWRpZW50VW5pdHNcIixcbiAgICBcImtlcm5lbE1hdHJpeFwiLFxuICAgIFwia2VybmVsVW5pdExlbmd0aFwiLFxuICAgIFwia2V5UG9pbnRzXCIsXG4gICAgXCJrZXlTcGxpbmVzXCIsXG4gICAgXCJrZXlUaW1lc1wiLFxuICAgIFwibGVuZ3RoQWRqdXN0XCIsXG4gICAgXCJsaW1pdGluZ0NvbmVBbmdsZVwiLFxuICAgIFwibWFya2VySGVpZ2h0XCIsXG4gICAgXCJtYXJrZXJVbml0c1wiLFxuICAgIFwibWFya2VyV2lkdGhcIixcbiAgICBcIm1hc2tDb250ZW50VW5pdHNcIixcbiAgICBcIm1hc2tVbml0c1wiLFxuICAgIFwibnVtT2N0YXZlc1wiLFxuICAgIFwicGF0aExlbmd0aFwiLFxuICAgIFwicGF0dGVybkNvbnRlbnRVbml0c1wiLFxuICAgIFwicGF0dGVyblRyYW5zZm9ybVwiLFxuICAgIFwicGF0dGVyblVuaXRzXCIsXG4gICAgXCJwb2ludHNBdFhcIixcbiAgICBcInBvaW50c0F0WVwiLFxuICAgIFwicG9pbnRzQXRaXCIsXG4gICAgXCJwcmVzZXJ2ZUFscGhhXCIsXG4gICAgXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsXG4gICAgXCJwcmltaXRpdmVVbml0c1wiLFxuICAgIFwicmVmWFwiLFxuICAgIFwicmVmWVwiLFxuICAgIFwicmVwZWF0Q291bnRcIixcbiAgICBcInJlcGVhdER1clwiLFxuICAgIFwicmVxdWlyZWRFeHRlbnNpb25zXCIsXG4gICAgXCJyZXF1aXJlZEZlYXR1cmVzXCIsXG4gICAgXCJzcGVjdWxhckNvbnN0YW50XCIsXG4gICAgXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gICAgXCJzcHJlYWRNZXRob2RcIixcbiAgICBcInN0YXJ0T2Zmc2V0XCIsXG4gICAgXCJzdGREZXZpYXRpb25cIixcbiAgICBcInN0aXRjaFRpbGVzXCIsXG4gICAgXCJzdXJmYWNlU2NhbGVcIixcbiAgICBcInN5c3RlbUxhbmd1YWdlXCIsXG4gICAgXCJ0YWJsZVZhbHVlc1wiLFxuICAgIFwidGFyZ2V0WFwiLFxuICAgIFwidGFyZ2V0WVwiLFxuICAgIFwidGV4dExlbmd0aFwiLFxuICAgIFwidmlld0JveFwiLFxuICAgIFwidmlld1RhcmdldFwiLFxuICAgIFwieENoYW5uZWxTZWxlY3RvclwiLFxuICAgIFwieUNoYW5uZWxTZWxlY3RvclwiLFxuICAgIFwiem9vbUFuZFBhblwiLFxuXS5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gW3ZhbC50b0xvd2VyQ2FzZSgpLCB2YWxdOyB9KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/node_modules/dom-serializer/lib/foreignNames.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/htmlparser2/node_modules/dom-serializer/lib/index.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/htmlparser2/node_modules/dom-serializer/lib/index.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.render = void 0;\n/*\n * Module dependencies\n */\nvar ElementType = __importStar(__webpack_require__(/*! domelementtype */ \"(rsc)/../../../node_modules/domelementtype/lib/index.js\"));\nvar entities_1 = __webpack_require__(/*! entities */ \"(rsc)/../../../node_modules/entities/lib/index.js\");\n/**\n * Mixed-case SVG and MathML tags & attributes\n * recognized by the HTML parser.\n *\n * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign\n */\nvar foreignNames_js_1 = __webpack_require__(/*! ./foreignNames.js */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/dom-serializer/lib/foreignNames.js\");\nvar unencodedElements = new Set([\n    \"style\",\n    \"script\",\n    \"xmp\",\n    \"iframe\",\n    \"noembed\",\n    \"noframes\",\n    \"plaintext\",\n    \"noscript\",\n]);\nfunction replaceQuotes(value) {\n    return value.replace(/\"/g, \"&quot;\");\n}\n/**\n * Format attributes\n */\nfunction formatAttributes(attributes, opts) {\n    var _a;\n    if (!attributes)\n        return;\n    var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false\n        ? replaceQuotes\n        : opts.xmlMode || opts.encodeEntities !== \"utf8\"\n            ? entities_1.encodeXML\n            : entities_1.escapeAttribute;\n    return Object.keys(attributes)\n        .map(function (key) {\n        var _a, _b;\n        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : \"\";\n        if (opts.xmlMode === \"foreign\") {\n            /* Fix up mixed-case attribute names */\n            key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;\n        }\n        if (!opts.emptyAttrs && !opts.xmlMode && value === \"\") {\n            return key;\n        }\n        return \"\".concat(key, \"=\\\"\").concat(encode(value), \"\\\"\");\n    })\n        .join(\" \");\n}\n/**\n * Self-enclosing tags\n */\nvar singleTag = new Set([\n    \"area\",\n    \"base\",\n    \"basefont\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"frame\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"isindex\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n]);\n/**\n * Renders a DOM node or an array of DOM nodes to a string.\n *\n * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).\n *\n * @param node Node to be rendered.\n * @param options Changes serialization behavior\n */\nfunction render(node, options) {\n    if (options === void 0) { options = {}; }\n    var nodes = \"length\" in node ? node : [node];\n    var output = \"\";\n    for (var i = 0; i < nodes.length; i++) {\n        output += renderNode(nodes[i], options);\n    }\n    return output;\n}\nexports.render = render;\nexports[\"default\"] = render;\nfunction renderNode(node, options) {\n    switch (node.type) {\n        case ElementType.Root:\n            return render(node.children, options);\n        // @ts-expect-error We don't use `Doctype` yet\n        case ElementType.Doctype:\n        case ElementType.Directive:\n            return renderDirective(node);\n        case ElementType.Comment:\n            return renderComment(node);\n        case ElementType.CDATA:\n            return renderCdata(node);\n        case ElementType.Script:\n        case ElementType.Style:\n        case ElementType.Tag:\n            return renderTag(node, options);\n        case ElementType.Text:\n            return renderText(node, options);\n    }\n}\nvar foreignModeIntegrationPoints = new Set([\n    \"mi\",\n    \"mo\",\n    \"mn\",\n    \"ms\",\n    \"mtext\",\n    \"annotation-xml\",\n    \"foreignObject\",\n    \"desc\",\n    \"title\",\n]);\nvar foreignElements = new Set([\"svg\", \"math\"]);\nfunction renderTag(elem, opts) {\n    var _a;\n    // Handle SVG / MathML in HTML\n    if (opts.xmlMode === \"foreign\") {\n        /* Fix up mixed-case element names */\n        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;\n        /* Exit foreign mode at integration points */\n        if (elem.parent &&\n            foreignModeIntegrationPoints.has(elem.parent.name)) {\n            opts = __assign(__assign({}, opts), { xmlMode: false });\n        }\n    }\n    if (!opts.xmlMode && foreignElements.has(elem.name)) {\n        opts = __assign(__assign({}, opts), { xmlMode: \"foreign\" });\n    }\n    var tag = \"<\".concat(elem.name);\n    var attribs = formatAttributes(elem.attribs, opts);\n    if (attribs) {\n        tag += \" \".concat(attribs);\n    }\n    if (elem.children.length === 0 &&\n        (opts.xmlMode\n            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags\n                opts.selfClosingTags !== false\n            : // User explicitly asked for self-closing tags, even in HTML mode\n                opts.selfClosingTags && singleTag.has(elem.name))) {\n        if (!opts.xmlMode)\n            tag += \" \";\n        tag += \"/>\";\n    }\n    else {\n        tag += \">\";\n        if (elem.children.length > 0) {\n            tag += render(elem.children, opts);\n        }\n        if (opts.xmlMode || !singleTag.has(elem.name)) {\n            tag += \"</\".concat(elem.name, \">\");\n        }\n    }\n    return tag;\n}\nfunction renderDirective(elem) {\n    return \"<\".concat(elem.data, \">\");\n}\nfunction renderText(elem, opts) {\n    var _a;\n    var data = elem.data || \"\";\n    // If entities weren't decoded, no need to encode them back\n    if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false &&\n        !(!opts.xmlMode &&\n            elem.parent &&\n            unencodedElements.has(elem.parent.name))) {\n        data =\n            opts.xmlMode || opts.encodeEntities !== \"utf8\"\n                ? (0, entities_1.encodeXML)(data)\n                : (0, entities_1.escapeText)(data);\n    }\n    return data;\n}\nfunction renderCdata(elem) {\n    return \"<![CDATA[\".concat(elem.children[0].data, \"]]>\");\n}\nfunction renderComment(elem) {\n    return \"<!--\".concat(elem.data, \"-->\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9kb20tc2VyaWFsaXplci9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLCtFQUFnQjtBQUN2RCxpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxrSEFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXLGdCQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVyxvQkFBb0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG9ydWsvaHViLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9ub2RlX21vZHVsZXMvZG9tLXNlcmlhbGl6ZXIvbGliL2luZGV4LmpzP2ZjODciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlbmRlciA9IHZvaWQgMDtcbi8qXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cbnZhciBFbGVtZW50VHlwZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZG9tZWxlbWVudHR5cGVcIikpO1xudmFyIGVudGl0aWVzXzEgPSByZXF1aXJlKFwiZW50aXRpZXNcIik7XG4vKipcbiAqIE1peGVkLWNhc2UgU1ZHIGFuZCBNYXRoTUwgdGFncyAmIGF0dHJpYnV0ZXNcbiAqIHJlY29nbml6ZWQgYnkgdGhlIEhUTUwgcGFyc2VyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3BhcnNpbmctbWFpbi1pbmZvcmVpZ25cbiAqL1xudmFyIGZvcmVpZ25OYW1lc19qc18xID0gcmVxdWlyZShcIi4vZm9yZWlnbk5hbWVzLmpzXCIpO1xudmFyIHVuZW5jb2RlZEVsZW1lbnRzID0gbmV3IFNldChbXG4gICAgXCJzdHlsZVwiLFxuICAgIFwic2NyaXB0XCIsXG4gICAgXCJ4bXBcIixcbiAgICBcImlmcmFtZVwiLFxuICAgIFwibm9lbWJlZFwiLFxuICAgIFwibm9mcmFtZXNcIixcbiAgICBcInBsYWludGV4dFwiLFxuICAgIFwibm9zY3JpcHRcIixcbl0pO1xuZnVuY3Rpb24gcmVwbGFjZVF1b3Rlcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKTtcbn1cbi8qKlxuICogRm9ybWF0IGF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBvcHRzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghYXR0cmlidXRlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBlbmNvZGUgPSAoKF9hID0gb3B0cy5lbmNvZGVFbnRpdGllcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3B0cy5kZWNvZGVFbnRpdGllcykgPT09IGZhbHNlXG4gICAgICAgID8gcmVwbGFjZVF1b3Rlc1xuICAgICAgICA6IG9wdHMueG1sTW9kZSB8fCBvcHRzLmVuY29kZUVudGl0aWVzICE9PSBcInV0ZjhcIlxuICAgICAgICAgICAgPyBlbnRpdGllc18xLmVuY29kZVhNTFxuICAgICAgICAgICAgOiBlbnRpdGllc18xLmVzY2FwZUF0dHJpYnV0ZTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlidXRlcylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciB2YWx1ZSA9IChfYSA9IGF0dHJpYnV0ZXNba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgaWYgKG9wdHMueG1sTW9kZSA9PT0gXCJmb3JlaWduXCIpIHtcbiAgICAgICAgICAgIC8qIEZpeCB1cCBtaXhlZC1jYXNlIGF0dHJpYnV0ZSBuYW1lcyAqL1xuICAgICAgICAgICAga2V5ID0gKF9iID0gZm9yZWlnbk5hbWVzX2pzXzEuYXR0cmlidXRlTmFtZXMuZ2V0KGtleSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdHMuZW1wdHlBdHRycyAmJiAhb3B0cy54bWxNb2RlICYmIHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrZXksIFwiPVxcXCJcIikuY29uY2F0KGVuY29kZSh2YWx1ZSksIFwiXFxcIlwiKTtcbiAgICB9KVxuICAgICAgICAuam9pbihcIiBcIik7XG59XG4vKipcbiAqIFNlbGYtZW5jbG9zaW5nIHRhZ3NcbiAqL1xudmFyIHNpbmdsZVRhZyA9IG5ldyBTZXQoW1xuICAgIFwiYXJlYVwiLFxuICAgIFwiYmFzZVwiLFxuICAgIFwiYmFzZWZvbnRcIixcbiAgICBcImJyXCIsXG4gICAgXCJjb2xcIixcbiAgICBcImNvbW1hbmRcIixcbiAgICBcImVtYmVkXCIsXG4gICAgXCJmcmFtZVwiLFxuICAgIFwiaHJcIixcbiAgICBcImltZ1wiLFxuICAgIFwiaW5wdXRcIixcbiAgICBcImlzaW5kZXhcIixcbiAgICBcImtleWdlblwiLFxuICAgIFwibGlua1wiLFxuICAgIFwibWV0YVwiLFxuICAgIFwicGFyYW1cIixcbiAgICBcInNvdXJjZVwiLFxuICAgIFwidHJhY2tcIixcbiAgICBcIndiclwiLFxuXSk7XG4vKipcbiAqIFJlbmRlcnMgYSBET00gbm9kZSBvciBhbiBhcnJheSBvZiBET00gbm9kZXMgdG8gYSBzdHJpbmcuXG4gKlxuICogQ2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIGVxdWl2YWxlbnQgb2YgdGhlIGBvdXRlckhUTUxgIG9mIHRoZSBwYXNzZWQgbm9kZShzKS5cbiAqXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGJlIHJlbmRlcmVkLlxuICogQHBhcmFtIG9wdGlvbnMgQ2hhbmdlcyBzZXJpYWxpemF0aW9uIGJlaGF2aW9yXG4gKi9cbmZ1bmN0aW9uIHJlbmRlcihub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgbm9kZXMgPSBcImxlbmd0aFwiIGluIG5vZGUgPyBub2RlIDogW25vZGVdO1xuICAgIHZhciBvdXRwdXQgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0ICs9IHJlbmRlck5vZGUobm9kZXNbaV0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuZXhwb3J0cy5yZW5kZXIgPSByZW5kZXI7XG5leHBvcnRzLmRlZmF1bHQgPSByZW5kZXI7XG5mdW5jdGlvbiByZW5kZXJOb2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIEVsZW1lbnRUeXBlLlJvb3Q6XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyKG5vZGUuY2hpbGRyZW4sIG9wdGlvbnMpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGRvbid0IHVzZSBgRG9jdHlwZWAgeWV0XG4gICAgICAgIGNhc2UgRWxlbWVudFR5cGUuRG9jdHlwZTpcbiAgICAgICAgY2FzZSBFbGVtZW50VHlwZS5EaXJlY3RpdmU6XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyRGlyZWN0aXZlKG5vZGUpO1xuICAgICAgICBjYXNlIEVsZW1lbnRUeXBlLkNvbW1lbnQ6XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyQ29tbWVudChub2RlKTtcbiAgICAgICAgY2FzZSBFbGVtZW50VHlwZS5DREFUQTpcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJDZGF0YShub2RlKTtcbiAgICAgICAgY2FzZSBFbGVtZW50VHlwZS5TY3JpcHQ6XG4gICAgICAgIGNhc2UgRWxlbWVudFR5cGUuU3R5bGU6XG4gICAgICAgIGNhc2UgRWxlbWVudFR5cGUuVGFnOlxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlclRhZyhub2RlLCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBFbGVtZW50VHlwZS5UZXh0OlxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlclRleHQobm9kZSwgb3B0aW9ucyk7XG4gICAgfVxufVxudmFyIGZvcmVpZ25Nb2RlSW50ZWdyYXRpb25Qb2ludHMgPSBuZXcgU2V0KFtcbiAgICBcIm1pXCIsXG4gICAgXCJtb1wiLFxuICAgIFwibW5cIixcbiAgICBcIm1zXCIsXG4gICAgXCJtdGV4dFwiLFxuICAgIFwiYW5ub3RhdGlvbi14bWxcIixcbiAgICBcImZvcmVpZ25PYmplY3RcIixcbiAgICBcImRlc2NcIixcbiAgICBcInRpdGxlXCIsXG5dKTtcbnZhciBmb3JlaWduRWxlbWVudHMgPSBuZXcgU2V0KFtcInN2Z1wiLCBcIm1hdGhcIl0pO1xuZnVuY3Rpb24gcmVuZGVyVGFnKGVsZW0sIG9wdHMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gSGFuZGxlIFNWRyAvIE1hdGhNTCBpbiBIVE1MXG4gICAgaWYgKG9wdHMueG1sTW9kZSA9PT0gXCJmb3JlaWduXCIpIHtcbiAgICAgICAgLyogRml4IHVwIG1peGVkLWNhc2UgZWxlbWVudCBuYW1lcyAqL1xuICAgICAgICBlbGVtLm5hbWUgPSAoX2EgPSBmb3JlaWduTmFtZXNfanNfMS5lbGVtZW50TmFtZXMuZ2V0KGVsZW0ubmFtZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVsZW0ubmFtZTtcbiAgICAgICAgLyogRXhpdCBmb3JlaWduIG1vZGUgYXQgaW50ZWdyYXRpb24gcG9pbnRzICovXG4gICAgICAgIGlmIChlbGVtLnBhcmVudCAmJlxuICAgICAgICAgICAgZm9yZWlnbk1vZGVJbnRlZ3JhdGlvblBvaW50cy5oYXMoZWxlbS5wYXJlbnQubmFtZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0cyksIHsgeG1sTW9kZTogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHRzLnhtbE1vZGUgJiYgZm9yZWlnbkVsZW1lbnRzLmhhcyhlbGVtLm5hbWUpKSB7XG4gICAgICAgIG9wdHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0cyksIHsgeG1sTW9kZTogXCJmb3JlaWduXCIgfSk7XG4gICAgfVxuICAgIHZhciB0YWcgPSBcIjxcIi5jb25jYXQoZWxlbS5uYW1lKTtcbiAgICB2YXIgYXR0cmlicyA9IGZvcm1hdEF0dHJpYnV0ZXMoZWxlbS5hdHRyaWJzLCBvcHRzKTtcbiAgICBpZiAoYXR0cmlicykge1xuICAgICAgICB0YWcgKz0gXCIgXCIuY29uY2F0KGF0dHJpYnMpO1xuICAgIH1cbiAgICBpZiAoZWxlbS5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgKG9wdHMueG1sTW9kZVxuICAgICAgICAgICAgPyAvLyBJbiBYTUwgbW9kZSBvciBmb3JlaWduIG1vZGUsIGFuZCB1c2VyIGhhc24ndCBleHBsaWNpdGx5IHR1cm5lZCBvZmYgc2VsZi1jbG9zaW5nIHRhZ3NcbiAgICAgICAgICAgICAgICBvcHRzLnNlbGZDbG9zaW5nVGFncyAhPT0gZmFsc2VcbiAgICAgICAgICAgIDogLy8gVXNlciBleHBsaWNpdGx5IGFza2VkIGZvciBzZWxmLWNsb3NpbmcgdGFncywgZXZlbiBpbiBIVE1MIG1vZGVcbiAgICAgICAgICAgICAgICBvcHRzLnNlbGZDbG9zaW5nVGFncyAmJiBzaW5nbGVUYWcuaGFzKGVsZW0ubmFtZSkpKSB7XG4gICAgICAgIGlmICghb3B0cy54bWxNb2RlKVxuICAgICAgICAgICAgdGFnICs9IFwiIFwiO1xuICAgICAgICB0YWcgKz0gXCIvPlwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFnICs9IFwiPlwiO1xuICAgICAgICBpZiAoZWxlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0YWcgKz0gcmVuZGVyKGVsZW0uY2hpbGRyZW4sIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnhtbE1vZGUgfHwgIXNpbmdsZVRhZy5oYXMoZWxlbS5uYW1lKSkge1xuICAgICAgICAgICAgdGFnICs9IFwiPC9cIi5jb25jYXQoZWxlbS5uYW1lLCBcIj5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhZztcbn1cbmZ1bmN0aW9uIHJlbmRlckRpcmVjdGl2ZShlbGVtKSB7XG4gICAgcmV0dXJuIFwiPFwiLmNvbmNhdChlbGVtLmRhdGEsIFwiPlwiKTtcbn1cbmZ1bmN0aW9uIHJlbmRlclRleHQoZWxlbSwgb3B0cykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZGF0YSA9IGVsZW0uZGF0YSB8fCBcIlwiO1xuICAgIC8vIElmIGVudGl0aWVzIHdlcmVuJ3QgZGVjb2RlZCwgbm8gbmVlZCB0byBlbmNvZGUgdGhlbSBiYWNrXG4gICAgaWYgKCgoX2EgPSBvcHRzLmVuY29kZUVudGl0aWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBvcHRzLmRlY29kZUVudGl0aWVzKSAhPT0gZmFsc2UgJiZcbiAgICAgICAgISghb3B0cy54bWxNb2RlICYmXG4gICAgICAgICAgICBlbGVtLnBhcmVudCAmJlxuICAgICAgICAgICAgdW5lbmNvZGVkRWxlbWVudHMuaGFzKGVsZW0ucGFyZW50Lm5hbWUpKSkge1xuICAgICAgICBkYXRhID1cbiAgICAgICAgICAgIG9wdHMueG1sTW9kZSB8fCBvcHRzLmVuY29kZUVudGl0aWVzICE9PSBcInV0ZjhcIlxuICAgICAgICAgICAgICAgID8gKDAsIGVudGl0aWVzXzEuZW5jb2RlWE1MKShkYXRhKVxuICAgICAgICAgICAgICAgIDogKDAsIGVudGl0aWVzXzEuZXNjYXBlVGV4dCkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gcmVuZGVyQ2RhdGEoZWxlbSkge1xuICAgIHJldHVybiBcIjwhW0NEQVRBW1wiLmNvbmNhdChlbGVtLmNoaWxkcmVuWzBdLmRhdGEsIFwiXV0+XCIpO1xufVxuZnVuY3Rpb24gcmVuZGVyQ29tbWVudChlbGVtKSB7XG4gICAgcmV0dXJuIFwiPCEtLVwiLmNvbmNhdChlbGVtLmRhdGEsIFwiLS0+XCIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/node_modules/dom-serializer/lib/index.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/feeds.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/htmlparser2/node_modules/domutils/lib/feeds.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getFeed = void 0;\nvar stringify_js_1 = __webpack_require__(/*! ./stringify.js */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/stringify.js\");\nvar legacy_js_1 = __webpack_require__(/*! ./legacy.js */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/legacy.js\");\n/**\n * Get the feed object from the root of a DOM tree.\n *\n * @category Feeds\n * @param doc - The DOM to to extract the feed from.\n * @returns The feed.\n */\nfunction getFeed(doc) {\n    var feedRoot = getOneElement(isValidFeed, doc);\n    return !feedRoot\n        ? null\n        : feedRoot.name === \"feed\"\n            ? getAtomFeed(feedRoot)\n            : getRssFeed(feedRoot);\n}\nexports.getFeed = getFeed;\n/**\n * Parse an Atom feed.\n *\n * @param feedRoot The root of the feed.\n * @returns The parsed feed.\n */\nfunction getAtomFeed(feedRoot) {\n    var _a;\n    var childs = feedRoot.children;\n    var feed = {\n        type: \"atom\",\n        items: (0, legacy_js_1.getElementsByTagName)(\"entry\", childs).map(function (item) {\n            var _a;\n            var children = item.children;\n            var entry = { media: getMediaElements(children) };\n            addConditionally(entry, \"id\", \"id\", children);\n            addConditionally(entry, \"title\", \"title\", children);\n            var href = (_a = getOneElement(\"link\", children)) === null || _a === void 0 ? void 0 : _a.attribs[\"href\"];\n            if (href) {\n                entry.link = href;\n            }\n            var description = fetch(\"summary\", children) || fetch(\"content\", children);\n            if (description) {\n                entry.description = description;\n            }\n            var pubDate = fetch(\"updated\", children);\n            if (pubDate) {\n                entry.pubDate = new Date(pubDate);\n            }\n            return entry;\n        }),\n    };\n    addConditionally(feed, \"id\", \"id\", childs);\n    addConditionally(feed, \"title\", \"title\", childs);\n    var href = (_a = getOneElement(\"link\", childs)) === null || _a === void 0 ? void 0 : _a.attribs[\"href\"];\n    if (href) {\n        feed.link = href;\n    }\n    addConditionally(feed, \"description\", \"subtitle\", childs);\n    var updated = fetch(\"updated\", childs);\n    if (updated) {\n        feed.updated = new Date(updated);\n    }\n    addConditionally(feed, \"author\", \"email\", childs, true);\n    return feed;\n}\n/**\n * Parse a RSS feed.\n *\n * @param feedRoot The root of the feed.\n * @returns The parsed feed.\n */\nfunction getRssFeed(feedRoot) {\n    var _a, _b;\n    var childs = (_b = (_a = getOneElement(\"channel\", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];\n    var feed = {\n        type: feedRoot.name.substr(0, 3),\n        id: \"\",\n        items: (0, legacy_js_1.getElementsByTagName)(\"item\", feedRoot.children).map(function (item) {\n            var children = item.children;\n            var entry = { media: getMediaElements(children) };\n            addConditionally(entry, \"id\", \"guid\", children);\n            addConditionally(entry, \"title\", \"title\", children);\n            addConditionally(entry, \"link\", \"link\", children);\n            addConditionally(entry, \"description\", \"description\", children);\n            var pubDate = fetch(\"pubDate\", children) || fetch(\"dc:date\", children);\n            if (pubDate)\n                entry.pubDate = new Date(pubDate);\n            return entry;\n        }),\n    };\n    addConditionally(feed, \"title\", \"title\", childs);\n    addConditionally(feed, \"link\", \"link\", childs);\n    addConditionally(feed, \"description\", \"description\", childs);\n    var updated = fetch(\"lastBuildDate\", childs);\n    if (updated) {\n        feed.updated = new Date(updated);\n    }\n    addConditionally(feed, \"author\", \"managingEditor\", childs, true);\n    return feed;\n}\nvar MEDIA_KEYS_STRING = [\"url\", \"type\", \"lang\"];\nvar MEDIA_KEYS_INT = [\n    \"fileSize\",\n    \"bitrate\",\n    \"framerate\",\n    \"samplingrate\",\n    \"channels\",\n    \"duration\",\n    \"height\",\n    \"width\",\n];\n/**\n * Get all media elements of a feed item.\n *\n * @param where Nodes to search in.\n * @returns Media elements.\n */\nfunction getMediaElements(where) {\n    return (0, legacy_js_1.getElementsByTagName)(\"media:content\", where).map(function (elem) {\n        var attribs = elem.attribs;\n        var media = {\n            medium: attribs[\"medium\"],\n            isDefault: !!attribs[\"isDefault\"],\n        };\n        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {\n            var attrib = MEDIA_KEYS_STRING_1[_i];\n            if (attribs[attrib]) {\n                media[attrib] = attribs[attrib];\n            }\n        }\n        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {\n            var attrib = MEDIA_KEYS_INT_1[_a];\n            if (attribs[attrib]) {\n                media[attrib] = parseInt(attribs[attrib], 10);\n            }\n        }\n        if (attribs[\"expression\"]) {\n            media.expression = attribs[\"expression\"];\n        }\n        return media;\n    });\n}\n/**\n * Get one element by tag name.\n *\n * @param tagName Tag name to look for\n * @param node Node to search in\n * @returns The element or null\n */\nfunction getOneElement(tagName, node) {\n    return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];\n}\n/**\n * Get the text content of an element with a certain tag name.\n *\n * @param tagName Tag name to look for.\n * @param where Node to search in.\n * @param recurse Whether to recurse into child nodes.\n * @returns The text content of the element.\n */\nfunction fetch(tagName, where, recurse) {\n    if (recurse === void 0) { recurse = false; }\n    return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();\n}\n/**\n * Adds a property to an object if it has a value.\n *\n * @param obj Object to be extended\n * @param prop Property name\n * @param tagName Tag name that contains the conditionally added property\n * @param where Element to search for the property\n * @param recurse Whether to recurse into child nodes.\n */\nfunction addConditionally(obj, prop, tagName, where, recurse) {\n    if (recurse === void 0) { recurse = false; }\n    var val = fetch(tagName, where, recurse);\n    if (val)\n        obj[prop] = val;\n}\n/**\n * Checks if an element is a feed root node.\n *\n * @param value The name of the element to check.\n * @returns Whether an element is a feed root node.\n */\nfunction isValidFeed(value) {\n    return value === \"rss\" || value === \"feed\" || value === \"rdf:RDF\";\n}\n//# sourceMappingURL=feeds.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvZmVlZHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLHFCQUFxQixtQkFBTyxDQUFDLHNHQUFnQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxnR0FBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsaUNBQWlDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsOEJBQThCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG9ydWsvaHViLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9ub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL2ZlZWRzLmpzPzBhOGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEZlZWQgPSB2b2lkIDA7XG52YXIgc3RyaW5naWZ5X2pzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIik7XG52YXIgbGVnYWN5X2pzXzEgPSByZXF1aXJlKFwiLi9sZWdhY3kuanNcIik7XG4vKipcbiAqIEdldCB0aGUgZmVlZCBvYmplY3QgZnJvbSB0aGUgcm9vdCBvZiBhIERPTSB0cmVlLlxuICpcbiAqIEBjYXRlZ29yeSBGZWVkc1xuICogQHBhcmFtIGRvYyAtIFRoZSBET00gdG8gdG8gZXh0cmFjdCB0aGUgZmVlZCBmcm9tLlxuICogQHJldHVybnMgVGhlIGZlZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEZlZWQoZG9jKSB7XG4gICAgdmFyIGZlZWRSb290ID0gZ2V0T25lRWxlbWVudChpc1ZhbGlkRmVlZCwgZG9jKTtcbiAgICByZXR1cm4gIWZlZWRSb290XG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IGZlZWRSb290Lm5hbWUgPT09IFwiZmVlZFwiXG4gICAgICAgICAgICA/IGdldEF0b21GZWVkKGZlZWRSb290KVxuICAgICAgICAgICAgOiBnZXRSc3NGZWVkKGZlZWRSb290KTtcbn1cbmV4cG9ydHMuZ2V0RmVlZCA9IGdldEZlZWQ7XG4vKipcbiAqIFBhcnNlIGFuIEF0b20gZmVlZC5cbiAqXG4gKiBAcGFyYW0gZmVlZFJvb3QgVGhlIHJvb3Qgb2YgdGhlIGZlZWQuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGZlZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEF0b21GZWVkKGZlZWRSb290KSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBjaGlsZHMgPSBmZWVkUm9vdC5jaGlsZHJlbjtcbiAgICB2YXIgZmVlZCA9IHtcbiAgICAgICAgdHlwZTogXCJhdG9tXCIsXG4gICAgICAgIGl0ZW1zOiAoMCwgbGVnYWN5X2pzXzEuZ2V0RWxlbWVudHNCeVRhZ05hbWUpKFwiZW50cnlcIiwgY2hpbGRzKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGl0ZW0uY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB7IG1lZGlhOiBnZXRNZWRpYUVsZW1lbnRzKGNoaWxkcmVuKSB9O1xuICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJpZFwiLCBcImlkXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwidGl0bGVcIiwgXCJ0aXRsZVwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB2YXIgaHJlZiA9IChfYSA9IGdldE9uZUVsZW1lbnQoXCJsaW5rXCIsIGNoaWxkcmVuKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJpYnNbXCJocmVmXCJdO1xuICAgICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5saW5rID0gaHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZXNjcmlwdGlvbiA9IGZldGNoKFwic3VtbWFyeVwiLCBjaGlsZHJlbikgfHwgZmV0Y2goXCJjb250ZW50XCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIGVudHJ5LmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHViRGF0ZSA9IGZldGNoKFwidXBkYXRlZFwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICBpZiAocHViRGF0ZSkge1xuICAgICAgICAgICAgICAgIGVudHJ5LnB1YkRhdGUgPSBuZXcgRGF0ZShwdWJEYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgfSksXG4gICAgfTtcbiAgICBhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwiaWRcIiwgXCJpZFwiLCBjaGlsZHMpO1xuICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJ0aXRsZVwiLCBcInRpdGxlXCIsIGNoaWxkcyk7XG4gICAgdmFyIGhyZWYgPSAoX2EgPSBnZXRPbmVFbGVtZW50KFwibGlua1wiLCBjaGlsZHMpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cmlic1tcImhyZWZcIl07XG4gICAgaWYgKGhyZWYpIHtcbiAgICAgICAgZmVlZC5saW5rID0gaHJlZjtcbiAgICB9XG4gICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImRlc2NyaXB0aW9uXCIsIFwic3VidGl0bGVcIiwgY2hpbGRzKTtcbiAgICB2YXIgdXBkYXRlZCA9IGZldGNoKFwidXBkYXRlZFwiLCBjaGlsZHMpO1xuICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgIGZlZWQudXBkYXRlZCA9IG5ldyBEYXRlKHVwZGF0ZWQpO1xuICAgIH1cbiAgICBhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwiYXV0aG9yXCIsIFwiZW1haWxcIiwgY2hpbGRzLCB0cnVlKTtcbiAgICByZXR1cm4gZmVlZDtcbn1cbi8qKlxuICogUGFyc2UgYSBSU1MgZmVlZC5cbiAqXG4gKiBAcGFyYW0gZmVlZFJvb3QgVGhlIHJvb3Qgb2YgdGhlIGZlZWQuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGZlZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJzc0ZlZWQoZmVlZFJvb3QpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBjaGlsZHMgPSAoX2IgPSAoX2EgPSBnZXRPbmVFbGVtZW50KFwiY2hhbm5lbFwiLCBmZWVkUm9vdC5jaGlsZHJlbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGlsZHJlbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgdmFyIGZlZWQgPSB7XG4gICAgICAgIHR5cGU6IGZlZWRSb290Lm5hbWUuc3Vic3RyKDAsIDMpLFxuICAgICAgICBpZDogXCJcIixcbiAgICAgICAgaXRlbXM6ICgwLCBsZWdhY3lfanNfMS5nZXRFbGVtZW50c0J5VGFnTmFtZSkoXCJpdGVtXCIsIGZlZWRSb290LmNoaWxkcmVuKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGl0ZW0uY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB7IG1lZGlhOiBnZXRNZWRpYUVsZW1lbnRzKGNoaWxkcmVuKSB9O1xuICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJpZFwiLCBcImd1aWRcIiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJ0aXRsZVwiLCBcInRpdGxlXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwibGlua1wiLCBcImxpbmtcIiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJkZXNjcmlwdGlvblwiLCBcImRlc2NyaXB0aW9uXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIHZhciBwdWJEYXRlID0gZmV0Y2goXCJwdWJEYXRlXCIsIGNoaWxkcmVuKSB8fCBmZXRjaChcImRjOmRhdGVcIiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgaWYgKHB1YkRhdGUpXG4gICAgICAgICAgICAgICAgZW50cnkucHViRGF0ZSA9IG5ldyBEYXRlKHB1YkRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICB9KSxcbiAgICB9O1xuICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJ0aXRsZVwiLCBcInRpdGxlXCIsIGNoaWxkcyk7XG4gICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImxpbmtcIiwgXCJsaW5rXCIsIGNoaWxkcyk7XG4gICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImRlc2NyaXB0aW9uXCIsIFwiZGVzY3JpcHRpb25cIiwgY2hpbGRzKTtcbiAgICB2YXIgdXBkYXRlZCA9IGZldGNoKFwibGFzdEJ1aWxkRGF0ZVwiLCBjaGlsZHMpO1xuICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgIGZlZWQudXBkYXRlZCA9IG5ldyBEYXRlKHVwZGF0ZWQpO1xuICAgIH1cbiAgICBhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwiYXV0aG9yXCIsIFwibWFuYWdpbmdFZGl0b3JcIiwgY2hpbGRzLCB0cnVlKTtcbiAgICByZXR1cm4gZmVlZDtcbn1cbnZhciBNRURJQV9LRVlTX1NUUklORyA9IFtcInVybFwiLCBcInR5cGVcIiwgXCJsYW5nXCJdO1xudmFyIE1FRElBX0tFWVNfSU5UID0gW1xuICAgIFwiZmlsZVNpemVcIixcbiAgICBcImJpdHJhdGVcIixcbiAgICBcImZyYW1lcmF0ZVwiLFxuICAgIFwic2FtcGxpbmdyYXRlXCIsXG4gICAgXCJjaGFubmVsc1wiLFxuICAgIFwiZHVyYXRpb25cIixcbiAgICBcImhlaWdodFwiLFxuICAgIFwid2lkdGhcIixcbl07XG4vKipcbiAqIEdldCBhbGwgbWVkaWEgZWxlbWVudHMgb2YgYSBmZWVkIGl0ZW0uXG4gKlxuICogQHBhcmFtIHdoZXJlIE5vZGVzIHRvIHNlYXJjaCBpbi5cbiAqIEByZXR1cm5zIE1lZGlhIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBnZXRNZWRpYUVsZW1lbnRzKHdoZXJlKSB7XG4gICAgcmV0dXJuICgwLCBsZWdhY3lfanNfMS5nZXRFbGVtZW50c0J5VGFnTmFtZSkoXCJtZWRpYTpjb250ZW50XCIsIHdoZXJlKS5tYXAoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIGF0dHJpYnMgPSBlbGVtLmF0dHJpYnM7XG4gICAgICAgIHZhciBtZWRpYSA9IHtcbiAgICAgICAgICAgIG1lZGl1bTogYXR0cmlic1tcIm1lZGl1bVwiXSxcbiAgICAgICAgICAgIGlzRGVmYXVsdDogISFhdHRyaWJzW1wiaXNEZWZhdWx0XCJdLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIE1FRElBX0tFWVNfU1RSSU5HXzEgPSBNRURJQV9LRVlTX1NUUklORzsgX2kgPCBNRURJQV9LRVlTX1NUUklOR18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGF0dHJpYiA9IE1FRElBX0tFWVNfU1RSSU5HXzFbX2ldO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnNbYXR0cmliXSkge1xuICAgICAgICAgICAgICAgIG1lZGlhW2F0dHJpYl0gPSBhdHRyaWJzW2F0dHJpYl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBNRURJQV9LRVlTX0lOVF8xID0gTUVESUFfS0VZU19JTlQ7IF9hIDwgTUVESUFfS0VZU19JTlRfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWIgPSBNRURJQV9LRVlTX0lOVF8xW19hXTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJzW2F0dHJpYl0pIHtcbiAgICAgICAgICAgICAgICBtZWRpYVthdHRyaWJdID0gcGFyc2VJbnQoYXR0cmlic1thdHRyaWJdLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnNbXCJleHByZXNzaW9uXCJdKSB7XG4gICAgICAgICAgICBtZWRpYS5leHByZXNzaW9uID0gYXR0cmlic1tcImV4cHJlc3Npb25cIl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lZGlhO1xuICAgIH0pO1xufVxuLyoqXG4gKiBHZXQgb25lIGVsZW1lbnQgYnkgdGFnIG5hbWUuXG4gKlxuICogQHBhcmFtIHRhZ05hbWUgVGFnIG5hbWUgdG8gbG9vayBmb3JcbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gc2VhcmNoIGluXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudCBvciBudWxsXG4gKi9cbmZ1bmN0aW9uIGdldE9uZUVsZW1lbnQodGFnTmFtZSwgbm9kZSkge1xuICAgIHJldHVybiAoMCwgbGVnYWN5X2pzXzEuZ2V0RWxlbWVudHNCeVRhZ05hbWUpKHRhZ05hbWUsIG5vZGUsIHRydWUsIDEpWzBdO1xufVxuLyoqXG4gKiBHZXQgdGhlIHRleHQgY29udGVudCBvZiBhbiBlbGVtZW50IHdpdGggYSBjZXJ0YWluIHRhZyBuYW1lLlxuICpcbiAqIEBwYXJhbSB0YWdOYW1lIFRhZyBuYW1lIHRvIGxvb2sgZm9yLlxuICogQHBhcmFtIHdoZXJlIE5vZGUgdG8gc2VhcmNoIGluLlxuICogQHBhcmFtIHJlY3Vyc2UgV2hldGhlciB0byByZWN1cnNlIGludG8gY2hpbGQgbm9kZXMuXG4gKiBAcmV0dXJucyBUaGUgdGV4dCBjb250ZW50IG9mIHRoZSBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBmZXRjaCh0YWdOYW1lLCB3aGVyZSwgcmVjdXJzZSkge1xuICAgIGlmIChyZWN1cnNlID09PSB2b2lkIDApIHsgcmVjdXJzZSA9IGZhbHNlOyB9XG4gICAgcmV0dXJuICgwLCBzdHJpbmdpZnlfanNfMS50ZXh0Q29udGVudCkoKDAsIGxlZ2FjeV9qc18xLmdldEVsZW1lbnRzQnlUYWdOYW1lKSh0YWdOYW1lLCB3aGVyZSwgcmVjdXJzZSwgMSkpLnRyaW0oKTtcbn1cbi8qKlxuICogQWRkcyBhIHByb3BlcnR5IHRvIGFuIG9iamVjdCBpZiBpdCBoYXMgYSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gb2JqIE9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHByb3AgUHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHRhZ05hbWUgVGFnIG5hbWUgdGhhdCBjb250YWlucyB0aGUgY29uZGl0aW9uYWxseSBhZGRlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHdoZXJlIEVsZW1lbnQgdG8gc2VhcmNoIGZvciB0aGUgcHJvcGVydHlcbiAqIEBwYXJhbSByZWN1cnNlIFdoZXRoZXIgdG8gcmVjdXJzZSBpbnRvIGNoaWxkIG5vZGVzLlxuICovXG5mdW5jdGlvbiBhZGRDb25kaXRpb25hbGx5KG9iaiwgcHJvcCwgdGFnTmFtZSwgd2hlcmUsIHJlY3Vyc2UpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSBmYWxzZTsgfVxuICAgIHZhciB2YWwgPSBmZXRjaCh0YWdOYW1lLCB3aGVyZSwgcmVjdXJzZSk7XG4gICAgaWYgKHZhbClcbiAgICAgICAgb2JqW3Byb3BdID0gdmFsO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZWxlbWVudCBpcyBhIGZlZWQgcm9vdCBub2RlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgbmFtZSBvZiB0aGUgZWxlbWVudCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgYW4gZWxlbWVudCBpcyBhIGZlZWQgcm9vdCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRmVlZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gXCJyc3NcIiB8fCB2YWx1ZSA9PT0gXCJmZWVkXCIgfHwgdmFsdWUgPT09IFwicmRmOlJERlwiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmVlZHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/feeds.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/helpers.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/htmlparser2/node_modules/domutils/lib/helpers.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/../../../node_modules/domhandler/lib/index.js\");\n/**\n * Given an array of nodes, remove any member that is contained by another\n * member.\n *\n * @category Helpers\n * @param nodes Nodes to filter.\n * @returns Remaining nodes that aren't contained by other nodes.\n */\nfunction removeSubsets(nodes) {\n    var idx = nodes.length;\n    /*\n     * Check if each node (or one of its ancestors) is already contained in the\n     * array.\n     */\n    while (--idx >= 0) {\n        var node = nodes[idx];\n        /*\n         * Remove the node if it is not unique.\n         * We are going through the array from the end, so we only\n         * have to check nodes that preceed the node under consideration in the array.\n         */\n        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\n            nodes.splice(idx, 1);\n            continue;\n        }\n        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n            if (nodes.includes(ancestor)) {\n                nodes.splice(idx, 1);\n                break;\n            }\n        }\n    }\n    return nodes;\n}\nexports.removeSubsets = removeSubsets;\n/**\n * @category Helpers\n * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}\n */\nvar DocumentPosition;\n(function (DocumentPosition) {\n    DocumentPosition[DocumentPosition[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n    DocumentPosition[DocumentPosition[\"PRECEDING\"] = 2] = \"PRECEDING\";\n    DocumentPosition[DocumentPosition[\"FOLLOWING\"] = 4] = \"FOLLOWING\";\n    DocumentPosition[DocumentPosition[\"CONTAINS\"] = 8] = \"CONTAINS\";\n    DocumentPosition[DocumentPosition[\"CONTAINED_BY\"] = 16] = \"CONTAINED_BY\";\n})(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));\n/**\n * Compare the position of one node against another node in any other document,\n * returning a bitmask with the values from {@link DocumentPosition}.\n *\n * Document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent.\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n *\n * @category Helpers\n * @param nodeA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n * @returns A bitmask describing the input nodes' relative position.\n *\n * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n * a description of these values.\n */\nfunction compareDocumentPosition(nodeA, nodeB) {\n    var aParents = [];\n    var bParents = [];\n    if (nodeA === nodeB) {\n        return 0;\n    }\n    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;\n    while (current) {\n        aParents.unshift(current);\n        current = current.parent;\n    }\n    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;\n    while (current) {\n        bParents.unshift(current);\n        current = current.parent;\n    }\n    var maxIdx = Math.min(aParents.length, bParents.length);\n    var idx = 0;\n    while (idx < maxIdx && aParents[idx] === bParents[idx]) {\n        idx++;\n    }\n    if (idx === 0) {\n        return DocumentPosition.DISCONNECTED;\n    }\n    var sharedParent = aParents[idx - 1];\n    var siblings = sharedParent.children;\n    var aSibling = aParents[idx];\n    var bSibling = bParents[idx];\n    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n        if (sharedParent === nodeB) {\n            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;\n        }\n        return DocumentPosition.FOLLOWING;\n    }\n    if (sharedParent === nodeA) {\n        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;\n    }\n    return DocumentPosition.PRECEDING;\n}\nexports.compareDocumentPosition = compareDocumentPosition;\n/**\n * Sort an array of nodes based on their relative position in the document,\n * removing any duplicate nodes. If the array contains nodes that do not belong\n * to the same document, sort order is unspecified.\n *\n * @category Helpers\n * @param nodes Array of DOM nodes.\n * @returns Collection of unique nodes, sorted in document order.\n */\nfunction uniqueSort(nodes) {\n    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });\n    nodes.sort(function (a, b) {\n        var relative = compareDocumentPosition(a, b);\n        if (relative & DocumentPosition.PRECEDING) {\n            return -1;\n        }\n        else if (relative & DocumentPosition.FOLLOWING) {\n            return 1;\n        }\n        return 0;\n    });\n    return nodes;\n}\nexports.uniqueSort = uniqueSort;\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRywrQkFBK0IsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUI7QUFDdkcsbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELHdCQUF3QixLQUFLO0FBQ2hGO0FBQ0E7QUFDQSw2Q0FBNkMsdUJBQXVCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0NBQW9DO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG9ydWsvaHViLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9ub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL2hlbHBlcnMuanM/NDI0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5pcXVlU29ydCA9IGV4cG9ydHMuY29tcGFyZURvY3VtZW50UG9zaXRpb24gPSBleHBvcnRzLkRvY3VtZW50UG9zaXRpb24gPSBleHBvcnRzLnJlbW92ZVN1YnNldHMgPSB2b2lkIDA7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcImRvbWhhbmRsZXJcIik7XG4vKipcbiAqIEdpdmVuIGFuIGFycmF5IG9mIG5vZGVzLCByZW1vdmUgYW55IG1lbWJlciB0aGF0IGlzIGNvbnRhaW5lZCBieSBhbm90aGVyXG4gKiBtZW1iZXIuXG4gKlxuICogQGNhdGVnb3J5IEhlbHBlcnNcbiAqIEBwYXJhbSBub2RlcyBOb2RlcyB0byBmaWx0ZXIuXG4gKiBAcmV0dXJucyBSZW1haW5pbmcgbm9kZXMgdGhhdCBhcmVuJ3QgY29udGFpbmVkIGJ5IG90aGVyIG5vZGVzLlxuICovXG5mdW5jdGlvbiByZW1vdmVTdWJzZXRzKG5vZGVzKSB7XG4gICAgdmFyIGlkeCA9IG5vZGVzLmxlbmd0aDtcbiAgICAvKlxuICAgICAqIENoZWNrIGlmIGVhY2ggbm9kZSAob3Igb25lIG9mIGl0cyBhbmNlc3RvcnMpIGlzIGFscmVhZHkgY29udGFpbmVkIGluIHRoZVxuICAgICAqIGFycmF5LlxuICAgICAqL1xuICAgIHdoaWxlICgtLWlkeCA+PSAwKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaWR4XTtcbiAgICAgICAgLypcbiAgICAgICAgICogUmVtb3ZlIHRoZSBub2RlIGlmIGl0IGlzIG5vdCB1bmlxdWUuXG4gICAgICAgICAqIFdlIGFyZSBnb2luZyB0aHJvdWdoIHRoZSBhcnJheSBmcm9tIHRoZSBlbmQsIHNvIHdlIG9ubHlcbiAgICAgICAgICogaGF2ZSB0byBjaGVjayBub2RlcyB0aGF0IHByZWNlZWQgdGhlIG5vZGUgdW5kZXIgY29uc2lkZXJhdGlvbiBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaWR4ID4gMCAmJiBub2Rlcy5sYXN0SW5kZXhPZihub2RlLCBpZHggLSAxKSA+PSAwKSB7XG4gICAgICAgICAgICBub2Rlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGFuY2VzdG9yID0gbm9kZS5wYXJlbnQ7IGFuY2VzdG9yOyBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGVzLmluY2x1ZGVzKGFuY2VzdG9yKSkge1xuICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbmV4cG9ydHMucmVtb3ZlU3Vic2V0cyA9IHJlbW92ZVN1YnNldHM7XG4vKipcbiAqIEBjYXRlZ29yeSBIZWxwZXJzXG4gKiBAc2VlIHtAbGluayBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLW5vZGUtY29tcGFyZWRvY3VtZW50cG9zaXRpb259XG4gKi9cbnZhciBEb2N1bWVudFBvc2l0aW9uO1xuKGZ1bmN0aW9uIChEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgRG9jdW1lbnRQb3NpdGlvbltEb2N1bWVudFBvc2l0aW9uW1wiRElTQ09OTkVDVEVEXCJdID0gMV0gPSBcIkRJU0NPTk5FQ1RFRFwiO1xuICAgIERvY3VtZW50UG9zaXRpb25bRG9jdW1lbnRQb3NpdGlvbltcIlBSRUNFRElOR1wiXSA9IDJdID0gXCJQUkVDRURJTkdcIjtcbiAgICBEb2N1bWVudFBvc2l0aW9uW0RvY3VtZW50UG9zaXRpb25bXCJGT0xMT1dJTkdcIl0gPSA0XSA9IFwiRk9MTE9XSU5HXCI7XG4gICAgRG9jdW1lbnRQb3NpdGlvbltEb2N1bWVudFBvc2l0aW9uW1wiQ09OVEFJTlNcIl0gPSA4XSA9IFwiQ09OVEFJTlNcIjtcbiAgICBEb2N1bWVudFBvc2l0aW9uW0RvY3VtZW50UG9zaXRpb25bXCJDT05UQUlORURfQllcIl0gPSAxNl0gPSBcIkNPTlRBSU5FRF9CWVwiO1xufSkoRG9jdW1lbnRQb3NpdGlvbiA9IGV4cG9ydHMuRG9jdW1lbnRQb3NpdGlvbiB8fCAoZXhwb3J0cy5Eb2N1bWVudFBvc2l0aW9uID0ge30pKTtcbi8qKlxuICogQ29tcGFyZSB0aGUgcG9zaXRpb24gb2Ygb25lIG5vZGUgYWdhaW5zdCBhbm90aGVyIG5vZGUgaW4gYW55IG90aGVyIGRvY3VtZW50LFxuICogcmV0dXJuaW5nIGEgYml0bWFzayB3aXRoIHRoZSB2YWx1ZXMgZnJvbSB7QGxpbmsgRG9jdW1lbnRQb3NpdGlvbn0uXG4gKlxuICogRG9jdW1lbnQgb3JkZXI6XG4gKiA+IFRoZXJlIGlzIGFuIG9yZGVyaW5nLCBkb2N1bWVudCBvcmRlciwgZGVmaW5lZCBvbiBhbGwgdGhlIG5vZGVzIGluIHRoZVxuICogPiBkb2N1bWVudCBjb3JyZXNwb25kaW5nIHRvIHRoZSBvcmRlciBpbiB3aGljaCB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZVxuICogPiBYTUwgcmVwcmVzZW50YXRpb24gb2YgZWFjaCBub2RlIG9jY3VycyBpbiB0aGUgWE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICogPiBkb2N1bWVudCBhZnRlciBleHBhbnNpb24gb2YgZ2VuZXJhbCBlbnRpdGllcy4gVGh1cywgdGhlIGRvY3VtZW50IGVsZW1lbnRcbiAqID4gbm9kZSB3aWxsIGJlIHRoZSBmaXJzdCBub2RlLiBFbGVtZW50IG5vZGVzIG9jY3VyIGJlZm9yZSB0aGVpciBjaGlsZHJlbi5cbiAqID4gVGh1cywgZG9jdW1lbnQgb3JkZXIgb3JkZXJzIGVsZW1lbnQgbm9kZXMgaW4gb3JkZXIgb2YgdGhlIG9jY3VycmVuY2Ugb2ZcbiAqID4gdGhlaXIgc3RhcnQtdGFnIGluIHRoZSBYTUwgKGFmdGVyIGV4cGFuc2lvbiBvZiBlbnRpdGllcykuIFRoZSBhdHRyaWJ1dGVcbiAqID4gbm9kZXMgb2YgYW4gZWxlbWVudCBvY2N1ciBhZnRlciB0aGUgZWxlbWVudCBhbmQgYmVmb3JlIGl0cyBjaGlsZHJlbi4gVGhlXG4gKiA+IHJlbGF0aXZlIG9yZGVyIG9mIGF0dHJpYnV0ZSBub2RlcyBpcyBpbXBsZW1lbnRhdGlvbi1kZXBlbmRlbnQuXG4gKlxuICogU291cmNlOlxuICogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yZS9nbG9zc2FyeS5odG1sI2R0LWRvY3VtZW50LW9yZGVyXG4gKlxuICogQGNhdGVnb3J5IEhlbHBlcnNcbiAqIEBwYXJhbSBub2RlQSBUaGUgZmlyc3Qgbm9kZSB0byB1c2UgaW4gdGhlIGNvbXBhcmlzb25cbiAqIEBwYXJhbSBub2RlQiBUaGUgc2Vjb25kIG5vZGUgdG8gdXNlIGluIHRoZSBjb21wYXJpc29uXG4gKiBAcmV0dXJucyBBIGJpdG1hc2sgZGVzY3JpYmluZyB0aGUgaW5wdXQgbm9kZXMnIHJlbGF0aXZlIHBvc2l0aW9uLlxuICpcbiAqIFNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLW5vZGUtY29tcGFyZWRvY3VtZW50cG9zaXRpb24gZm9yXG4gKiBhIGRlc2NyaXB0aW9uIG9mIHRoZXNlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZUEsIG5vZGVCKSB7XG4gICAgdmFyIGFQYXJlbnRzID0gW107XG4gICAgdmFyIGJQYXJlbnRzID0gW107XG4gICAgaWYgKG5vZGVBID09PSBub2RlQikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnQgPSAoMCwgZG9taGFuZGxlcl8xLmhhc0NoaWxkcmVuKShub2RlQSkgPyBub2RlQSA6IG5vZGVBLnBhcmVudDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBhUGFyZW50cy51bnNoaWZ0KGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQgPSAoMCwgZG9taGFuZGxlcl8xLmhhc0NoaWxkcmVuKShub2RlQikgPyBub2RlQiA6IG5vZGVCLnBhcmVudDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBiUGFyZW50cy51bnNoaWZ0KGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHZhciBtYXhJZHggPSBNYXRoLm1pbihhUGFyZW50cy5sZW5ndGgsIGJQYXJlbnRzLmxlbmd0aCk7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgd2hpbGUgKGlkeCA8IG1heElkeCAmJiBhUGFyZW50c1tpZHhdID09PSBiUGFyZW50c1tpZHhdKSB7XG4gICAgICAgIGlkeCsrO1xuICAgIH1cbiAgICBpZiAoaWR4ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBEb2N1bWVudFBvc2l0aW9uLkRJU0NPTk5FQ1RFRDtcbiAgICB9XG4gICAgdmFyIHNoYXJlZFBhcmVudCA9IGFQYXJlbnRzW2lkeCAtIDFdO1xuICAgIHZhciBzaWJsaW5ncyA9IHNoYXJlZFBhcmVudC5jaGlsZHJlbjtcbiAgICB2YXIgYVNpYmxpbmcgPSBhUGFyZW50c1tpZHhdO1xuICAgIHZhciBiU2libGluZyA9IGJQYXJlbnRzW2lkeF07XG4gICAgaWYgKHNpYmxpbmdzLmluZGV4T2YoYVNpYmxpbmcpID4gc2libGluZ3MuaW5kZXhPZihiU2libGluZykpIHtcbiAgICAgICAgaWYgKHNoYXJlZFBhcmVudCA9PT0gbm9kZUIpIHtcbiAgICAgICAgICAgIHJldHVybiBEb2N1bWVudFBvc2l0aW9uLkZPTExPV0lORyB8IERvY3VtZW50UG9zaXRpb24uQ09OVEFJTkVEX0JZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEb2N1bWVudFBvc2l0aW9uLkZPTExPV0lORztcbiAgICB9XG4gICAgaWYgKHNoYXJlZFBhcmVudCA9PT0gbm9kZUEpIHtcbiAgICAgICAgcmV0dXJuIERvY3VtZW50UG9zaXRpb24uUFJFQ0VESU5HIHwgRG9jdW1lbnRQb3NpdGlvbi5DT05UQUlOUztcbiAgICB9XG4gICAgcmV0dXJuIERvY3VtZW50UG9zaXRpb24uUFJFQ0VESU5HO1xufVxuZXhwb3J0cy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA9IGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuLyoqXG4gKiBTb3J0IGFuIGFycmF5IG9mIG5vZGVzIGJhc2VkIG9uIHRoZWlyIHJlbGF0aXZlIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCxcbiAqIHJlbW92aW5nIGFueSBkdXBsaWNhdGUgbm9kZXMuIElmIHRoZSBhcnJheSBjb250YWlucyBub2RlcyB0aGF0IGRvIG5vdCBiZWxvbmdcbiAqIHRvIHRoZSBzYW1lIGRvY3VtZW50LCBzb3J0IG9yZGVyIGlzIHVuc3BlY2lmaWVkLlxuICpcbiAqIEBjYXRlZ29yeSBIZWxwZXJzXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2YgRE9NIG5vZGVzLlxuICogQHJldHVybnMgQ29sbGVjdGlvbiBvZiB1bmlxdWUgbm9kZXMsIHNvcnRlZCBpbiBkb2N1bWVudCBvcmRlci5cbiAqL1xuZnVuY3Rpb24gdW5pcXVlU29ydChub2Rlcykge1xuICAgIG5vZGVzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlLCBpLCBhcnIpIHsgcmV0dXJuICFhcnIuaW5jbHVkZXMobm9kZSwgaSArIDEpOyB9KTtcbiAgICBub2Rlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGEsIGIpO1xuICAgICAgICBpZiAocmVsYXRpdmUgJiBEb2N1bWVudFBvc2l0aW9uLlBSRUNFRElORykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlbGF0aXZlICYgRG9jdW1lbnRQb3NpdGlvbi5GT0xMT1dJTkcpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIHJldHVybiBub2Rlcztcbn1cbmV4cG9ydHMudW5pcXVlU29ydCA9IHVuaXF1ZVNvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/helpers.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/index.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/htmlparser2/node_modules/domutils/lib/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;\n__exportStar(__webpack_require__(/*! ./stringify.js */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/stringify.js\"), exports);\n__exportStar(__webpack_require__(/*! ./traversal.js */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/traversal.js\"), exports);\n__exportStar(__webpack_require__(/*! ./manipulation.js */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/manipulation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./querying.js */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/querying.js\"), exports);\n__exportStar(__webpack_require__(/*! ./legacy.js */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/legacy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./helpers.js */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/helpers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./feeds.js */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/feeds.js\"), exports);\n/** @deprecated Use these methods from `domhandler` directly. */\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/../../../node_modules/domhandler/lib/index.js\");\nObject.defineProperty(exports, \"isTag\", ({ enumerable: true, get: function () { return domhandler_1.isTag; } }));\nObject.defineProperty(exports, \"isCDATA\", ({ enumerable: true, get: function () { return domhandler_1.isCDATA; } }));\nObject.defineProperty(exports, \"isText\", ({ enumerable: true, get: function () { return domhandler_1.isText; } }));\nObject.defineProperty(exports, \"isComment\", ({ enumerable: true, get: function () { return domhandler_1.isComment; } }));\nObject.defineProperty(exports, \"isDocument\", ({ enumerable: true, get: function () { return domhandler_1.isDocument; } }));\nObject.defineProperty(exports, \"hasChildren\", ({ enumerable: true, get: function () { return domhandler_1.hasChildren; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLGVBQWUsR0FBRyxhQUFhO0FBQy9HLGFBQWEsbUJBQU8sQ0FBQyxzR0FBZ0I7QUFDckMsYUFBYSxtQkFBTyxDQUFDLHNHQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsNEdBQW1CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyxvR0FBZTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsZ0dBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLGtHQUFjO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyw4RkFBWTtBQUNqQztBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3ZDLHlDQUF3QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUM5RywyQ0FBMEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbEgsMENBQXlDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2hILDZDQUE0QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN0SCw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDeEgsK0NBQThDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzFIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG9ydWsvaHViLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9ub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL2luZGV4LmpzPzQ0YTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzQ2hpbGRyZW4gPSBleHBvcnRzLmlzRG9jdW1lbnQgPSBleHBvcnRzLmlzQ29tbWVudCA9IGV4cG9ydHMuaXNUZXh0ID0gZXhwb3J0cy5pc0NEQVRBID0gZXhwb3J0cy5pc1RhZyA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYXZlcnNhbC5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWFuaXB1bGF0aW9uLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9xdWVyeWluZy5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGVnYWN5LmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mZWVkcy5qc1wiKSwgZXhwb3J0cyk7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIHRoZXNlIG1ldGhvZHMgZnJvbSBgZG9taGFuZGxlcmAgZGlyZWN0bHkuICovXG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcImRvbWhhbmRsZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1RhZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9taGFuZGxlcl8xLmlzVGFnOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNDREFUQVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9taGFuZGxlcl8xLmlzQ0RBVEE7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1RleHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbWhhbmRsZXJfMS5pc1RleHQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0NvbW1lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbWhhbmRsZXJfMS5pc0NvbW1lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0RvY3VtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb21oYW5kbGVyXzEuaXNEb2N1bWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc0NoaWxkcmVuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb21oYW5kbGVyXzEuaGFzQ2hpbGRyZW47IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/index.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/legacy.js":
/*!*****************************************************************************!*\
  !*** ../../../node_modules/htmlparser2/node_modules/domutils/lib/legacy.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/../../../node_modules/domhandler/lib/index.js\");\nvar querying_js_1 = __webpack_require__(/*! ./querying.js */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/querying.js\");\n/**\n * A map of functions to check nodes against.\n */\nvar Checks = {\n    tag_name: function (name) {\n        if (typeof name === \"function\") {\n            return function (elem) { return (0, domhandler_1.isTag)(elem) && name(elem.name); };\n        }\n        else if (name === \"*\") {\n            return domhandler_1.isTag;\n        }\n        return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.name === name; };\n    },\n    tag_type: function (type) {\n        if (typeof type === \"function\") {\n            return function (elem) { return type(elem.type); };\n        }\n        return function (elem) { return elem.type === type; };\n    },\n    tag_contains: function (data) {\n        if (typeof data === \"function\") {\n            return function (elem) { return (0, domhandler_1.isText)(elem) && data(elem.data); };\n        }\n        return function (elem) { return (0, domhandler_1.isText)(elem) && elem.data === data; };\n    },\n};\n/**\n * Returns a function to check whether a node has an attribute with a particular\n * value.\n *\n * @param attrib Attribute to check.\n * @param value Attribute value to look for.\n * @returns A function to check whether the a node has an attribute with a\n *   particular value.\n */\nfunction getAttribCheck(attrib, value) {\n    if (typeof value === \"function\") {\n        return function (elem) { return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]); };\n    }\n    return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value; };\n}\n/**\n * Returns a function that returns `true` if either of the input functions\n * returns `true` for a node.\n *\n * @param a First function to combine.\n * @param b Second function to combine.\n * @returns A function taking a node and returning `true` if either of the input\n *   functions returns `true` for the node.\n */\nfunction combineFuncs(a, b) {\n    return function (elem) { return a(elem) || b(elem); };\n}\n/**\n * Returns a function that executes all checks in `options` and returns `true`\n * if any of them match a node.\n *\n * @param options An object describing nodes to look for.\n * @returns A function that executes all checks in `options` and returns `true`\n *   if any of them match a node.\n */\nfunction compileTest(options) {\n    var funcs = Object.keys(options).map(function (key) {\n        var value = options[key];\n        return Object.prototype.hasOwnProperty.call(Checks, key)\n            ? Checks[key](value)\n            : getAttribCheck(key, value);\n    });\n    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);\n}\n/**\n * Checks whether a node matches the description in `options`.\n *\n * @category Legacy Query Functions\n * @param options An object describing nodes to look for.\n * @param node The element to test.\n * @returns Whether the element matches the description in `options`.\n */\nfunction testElement(options, node) {\n    var test = compileTest(options);\n    return test ? test(node) : true;\n}\nexports.testElement = testElement;\n/**\n * Returns all nodes that match `options`.\n *\n * @category Legacy Query Functions\n * @param options An object describing nodes to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes that match `options`.\n */\nfunction getElements(options, nodes, recurse, limit) {\n    if (limit === void 0) { limit = Infinity; }\n    var test = compileTest(options);\n    return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];\n}\nexports.getElements = getElements;\n/**\n * Returns the node with the supplied ID.\n *\n * @category Legacy Query Functions\n * @param id The unique ID attribute value to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @returns The node with the supplied ID.\n */\nfunction getElementById(id, nodes, recurse) {\n    if (recurse === void 0) { recurse = true; }\n    if (!Array.isArray(nodes))\n        nodes = [nodes];\n    return (0, querying_js_1.findOne)(getAttribCheck(\"id\", id), nodes, recurse);\n}\nexports.getElementById = getElementById;\n/**\n * Returns all nodes with the supplied `tagName`.\n *\n * @category Legacy Query Functions\n * @param tagName Tag name to search for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `tagName`.\n */\nfunction getElementsByTagName(tagName, nodes, recurse, limit) {\n    if (recurse === void 0) { recurse = true; }\n    if (limit === void 0) { limit = Infinity; }\n    return (0, querying_js_1.filter)(Checks[\"tag_name\"](tagName), nodes, recurse, limit);\n}\nexports.getElementsByTagName = getElementsByTagName;\n/**\n * Returns all nodes with the supplied `type`.\n *\n * @category Legacy Query Functions\n * @param type Element type to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `type`.\n */\nfunction getElementsByTagType(type, nodes, recurse, limit) {\n    if (recurse === void 0) { recurse = true; }\n    if (limit === void 0) { limit = Infinity; }\n    return (0, querying_js_1.filter)(Checks[\"tag_type\"](type), nodes, recurse, limit);\n}\nexports.getElementsByTagType = getElementsByTagType;\n//# sourceMappingURL=legacy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvbGVnYWN5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQjtBQUNoSSxtQkFBbUIsbUJBQU8sQ0FBQyx1RUFBWTtBQUN2QyxvQkFBb0IsbUJBQU8sQ0FBQyxvR0FBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxpQ0FBaUM7QUFDakMsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxpQ0FBaUM7QUFDakMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BvcnVrL2h1Yi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9sZWdhY3kuanM/MWYxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RWxlbWVudHNCeVRhZ1R5cGUgPSBleHBvcnRzLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gZXhwb3J0cy5nZXRFbGVtZW50QnlJZCA9IGV4cG9ydHMuZ2V0RWxlbWVudHMgPSBleHBvcnRzLnRlc3RFbGVtZW50ID0gdm9pZCAwO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xudmFyIHF1ZXJ5aW5nX2pzXzEgPSByZXF1aXJlKFwiLi9xdWVyeWluZy5qc1wiKTtcbi8qKlxuICogQSBtYXAgb2YgZnVuY3Rpb25zIHRvIGNoZWNrIG5vZGVzIGFnYWluc3QuXG4gKi9cbnZhciBDaGVja3MgPSB7XG4gICAgdGFnX25hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuICgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGVsZW0pICYmIG5hbWUoZWxlbS5uYW1lKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSBcIipcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRvbWhhbmRsZXJfMS5pc1RhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuICgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGVsZW0pICYmIGVsZW0ubmFtZSA9PT0gbmFtZTsgfTtcbiAgICB9LFxuICAgIHRhZ190eXBlOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB0eXBlKGVsZW0udHlwZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnR5cGUgPT09IHR5cGU7IH07XG4gICAgfSxcbiAgICB0YWdfY29udGFpbnM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuICgwLCBkb21oYW5kbGVyXzEuaXNUZXh0KShlbGVtKSAmJiBkYXRhKGVsZW0uZGF0YSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiAoMCwgZG9taGFuZGxlcl8xLmlzVGV4dCkoZWxlbSkgJiYgZWxlbS5kYXRhID09PSBkYXRhOyB9O1xuICAgIH0sXG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gY2hlY2sgd2hldGhlciBhIG5vZGUgaGFzIGFuIGF0dHJpYnV0ZSB3aXRoIGEgcGFydGljdWxhclxuICogdmFsdWUuXG4gKlxuICogQHBhcmFtIGF0dHJpYiBBdHRyaWJ1dGUgdG8gY2hlY2suXG4gKiBAcGFyYW0gdmFsdWUgQXR0cmlidXRlIHZhbHVlIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0byBjaGVjayB3aGV0aGVyIHRoZSBhIG5vZGUgaGFzIGFuIGF0dHJpYnV0ZSB3aXRoIGFcbiAqICAgcGFydGljdWxhciB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmliQ2hlY2soYXR0cmliLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuICgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGVsZW0pICYmIHZhbHVlKGVsZW0uYXR0cmlic1thdHRyaWJdKTsgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiAoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShlbGVtKSAmJiBlbGVtLmF0dHJpYnNbYXR0cmliXSA9PT0gdmFsdWU7IH07XG59XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHRydWVgIGlmIGVpdGhlciBvZiB0aGUgaW5wdXQgZnVuY3Rpb25zXG4gKiByZXR1cm5zIGB0cnVlYCBmb3IgYSBub2RlLlxuICpcbiAqIEBwYXJhbSBhIEZpcnN0IGZ1bmN0aW9uIHRvIGNvbWJpbmUuXG4gKiBAcGFyYW0gYiBTZWNvbmQgZnVuY3Rpb24gdG8gY29tYmluZS5cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGFraW5nIGEgbm9kZSBhbmQgcmV0dXJuaW5nIGB0cnVlYCBpZiBlaXRoZXIgb2YgdGhlIGlucHV0XG4gKiAgIGZ1bmN0aW9ucyByZXR1cm5zIGB0cnVlYCBmb3IgdGhlIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVGdW5jcyhhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBhKGVsZW0pIHx8IGIoZWxlbSk7IH07XG59XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFsbCBjaGVja3MgaW4gYG9wdGlvbnNgIGFuZCByZXR1cm5zIGB0cnVlYFxuICogaWYgYW55IG9mIHRoZW0gbWF0Y2ggYSBub2RlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIEFuIG9iamVjdCBkZXNjcmliaW5nIG5vZGVzIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFsbCBjaGVja3MgaW4gYG9wdGlvbnNgIGFuZCByZXR1cm5zIGB0cnVlYFxuICogICBpZiBhbnkgb2YgdGhlbSBtYXRjaCBhIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVUZXN0KG9wdGlvbnMpIHtcbiAgICB2YXIgZnVuY3MgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQ2hlY2tzLCBrZXkpXG4gICAgICAgICAgICA/IENoZWNrc1trZXldKHZhbHVlKVxuICAgICAgICAgICAgOiBnZXRBdHRyaWJDaGVjayhrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3MubGVuZ3RoID09PSAwID8gbnVsbCA6IGZ1bmNzLnJlZHVjZShjb21iaW5lRnVuY3MpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIG5vZGUgbWF0Y2hlcyB0aGUgZGVzY3JpcHRpb24gaW4gYG9wdGlvbnNgLlxuICpcbiAqIEBjYXRlZ29yeSBMZWdhY3kgUXVlcnkgRnVuY3Rpb25zXG4gKiBAcGFyYW0gb3B0aW9ucyBBbiBvYmplY3QgZGVzY3JpYmluZyBub2RlcyB0byBsb29rIGZvci5cbiAqIEBwYXJhbSBub2RlIFRoZSBlbGVtZW50IHRvIHRlc3QuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBlbGVtZW50IG1hdGNoZXMgdGhlIGRlc2NyaXB0aW9uIGluIGBvcHRpb25zYC5cbiAqL1xuZnVuY3Rpb24gdGVzdEVsZW1lbnQob3B0aW9ucywgbm9kZSkge1xuICAgIHZhciB0ZXN0ID0gY29tcGlsZVRlc3Qob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRlc3QgPyB0ZXN0KG5vZGUpIDogdHJ1ZTtcbn1cbmV4cG9ydHMudGVzdEVsZW1lbnQgPSB0ZXN0RWxlbWVudDtcbi8qKlxuICogUmV0dXJucyBhbGwgbm9kZXMgdGhhdCBtYXRjaCBgb3B0aW9uc2AuXG4gKlxuICogQGNhdGVnb3J5IExlZ2FjeSBRdWVyeSBGdW5jdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zIEFuIG9iamVjdCBkZXNjcmliaW5nIG5vZGVzIHRvIGxvb2sgZm9yLlxuICogQHBhcmFtIG5vZGVzIE5vZGVzIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIHJlY3Vyc2UgQWxzbyBjb25zaWRlciBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSBsaW1pdCBNYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBBbGwgbm9kZXMgdGhhdCBtYXRjaCBgb3B0aW9uc2AuXG4gKi9cbmZ1bmN0aW9uIGdldEVsZW1lbnRzKG9wdGlvbnMsIG5vZGVzLCByZWN1cnNlLCBsaW1pdCkge1xuICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gSW5maW5pdHk7IH1cbiAgICB2YXIgdGVzdCA9IGNvbXBpbGVUZXN0KG9wdGlvbnMpO1xuICAgIHJldHVybiB0ZXN0ID8gKDAsIHF1ZXJ5aW5nX2pzXzEuZmlsdGVyKSh0ZXN0LCBub2RlcywgcmVjdXJzZSwgbGltaXQpIDogW107XG59XG5leHBvcnRzLmdldEVsZW1lbnRzID0gZ2V0RWxlbWVudHM7XG4vKipcbiAqIFJldHVybnMgdGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gKlxuICogQGNhdGVnb3J5IExlZ2FjeSBRdWVyeSBGdW5jdGlvbnNcbiAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIElEIGF0dHJpYnV0ZSB2YWx1ZSB0byBsb29rIGZvci5cbiAqIEBwYXJhbSBub2RlcyBOb2RlcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKiBAcmV0dXJucyBUaGUgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQsIG5vZGVzLCByZWN1cnNlKSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gdHJ1ZTsgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpXG4gICAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICByZXR1cm4gKDAsIHF1ZXJ5aW5nX2pzXzEuZmluZE9uZSkoZ2V0QXR0cmliQ2hlY2soXCJpZFwiLCBpZCksIG5vZGVzLCByZWN1cnNlKTtcbn1cbmV4cG9ydHMuZ2V0RWxlbWVudEJ5SWQgPSBnZXRFbGVtZW50QnlJZDtcbi8qKlxuICogUmV0dXJucyBhbGwgbm9kZXMgd2l0aCB0aGUgc3VwcGxpZWQgYHRhZ05hbWVgLlxuICpcbiAqIEBjYXRlZ29yeSBMZWdhY3kgUXVlcnkgRnVuY3Rpb25zXG4gKiBAcGFyYW0gdGFnTmFtZSBUYWcgbmFtZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIG5vZGVzIE5vZGVzIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIHJlY3Vyc2UgQWxzbyBjb25zaWRlciBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSBsaW1pdCBNYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBBbGwgbm9kZXMgd2l0aCB0aGUgc3VwcGxpZWQgYHRhZ05hbWVgLlxuICovXG5mdW5jdGlvbiBnZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lLCBub2RlcywgcmVjdXJzZSwgbGltaXQpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSB0cnVlOyB9XG4gICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSBJbmZpbml0eTsgfVxuICAgIHJldHVybiAoMCwgcXVlcnlpbmdfanNfMS5maWx0ZXIpKENoZWNrc1tcInRhZ19uYW1lXCJdKHRhZ05hbWUpLCBub2RlcywgcmVjdXJzZSwgbGltaXQpO1xufVxuZXhwb3J0cy5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGdldEVsZW1lbnRzQnlUYWdOYW1lO1xuLyoqXG4gKiBSZXR1cm5zIGFsbCBub2RlcyB3aXRoIHRoZSBzdXBwbGllZCBgdHlwZWAuXG4gKlxuICogQGNhdGVnb3J5IExlZ2FjeSBRdWVyeSBGdW5jdGlvbnNcbiAqIEBwYXJhbSB0eXBlIEVsZW1lbnQgdHlwZSB0byBsb29rIGZvci5cbiAqIEBwYXJhbSBub2RlcyBOb2RlcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKiBAcGFyYW0gbGltaXQgTWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgdG8gcmV0dXJuLlxuICogQHJldHVybnMgQWxsIG5vZGVzIHdpdGggdGhlIHN1cHBsaWVkIGB0eXBlYC5cbiAqL1xuZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVRhZ1R5cGUodHlwZSwgbm9kZXMsIHJlY3Vyc2UsIGxpbWl0KSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gdHJ1ZTsgfVxuICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gSW5maW5pdHk7IH1cbiAgICByZXR1cm4gKDAsIHF1ZXJ5aW5nX2pzXzEuZmlsdGVyKShDaGVja3NbXCJ0YWdfdHlwZVwiXSh0eXBlKSwgbm9kZXMsIHJlY3Vyc2UsIGxpbWl0KTtcbn1cbmV4cG9ydHMuZ2V0RWxlbWVudHNCeVRhZ1R5cGUgPSBnZXRFbGVtZW50c0J5VGFnVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlZ2FjeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/legacy.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/manipulation.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/htmlparser2/node_modules/domutils/lib/manipulation.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;\n/**\n * Remove an element from the dom\n *\n * @category Manipulation\n * @param elem The element to be removed\n */\nfunction removeElement(elem) {\n    if (elem.prev)\n        elem.prev.next = elem.next;\n    if (elem.next)\n        elem.next.prev = elem.prev;\n    if (elem.parent) {\n        var childs = elem.parent.children;\n        var childsIndex = childs.lastIndexOf(elem);\n        if (childsIndex >= 0) {\n            childs.splice(childsIndex, 1);\n        }\n    }\n    elem.next = null;\n    elem.prev = null;\n    elem.parent = null;\n}\nexports.removeElement = removeElement;\n/**\n * Replace an element in the dom\n *\n * @category Manipulation\n * @param elem The element to be replaced\n * @param replacement The element to be added\n */\nfunction replaceElement(elem, replacement) {\n    var prev = (replacement.prev = elem.prev);\n    if (prev) {\n        prev.next = replacement;\n    }\n    var next = (replacement.next = elem.next);\n    if (next) {\n        next.prev = replacement;\n    }\n    var parent = (replacement.parent = elem.parent);\n    if (parent) {\n        var childs = parent.children;\n        childs[childs.lastIndexOf(elem)] = replacement;\n        elem.parent = null;\n    }\n}\nexports.replaceElement = replaceElement;\n/**\n * Append a child to an element.\n *\n * @category Manipulation\n * @param parent The element to append to.\n * @param child The element to be added as a child.\n */\nfunction appendChild(parent, child) {\n    removeElement(child);\n    child.next = null;\n    child.parent = parent;\n    if (parent.children.push(child) > 1) {\n        var sibling = parent.children[parent.children.length - 2];\n        sibling.next = child;\n        child.prev = sibling;\n    }\n    else {\n        child.prev = null;\n    }\n}\nexports.appendChild = appendChild;\n/**\n * Append an element after another.\n *\n * @category Manipulation\n * @param elem The element to append after.\n * @param next The element be added.\n */\nfunction append(elem, next) {\n    removeElement(next);\n    var parent = elem.parent;\n    var currNext = elem.next;\n    next.next = currNext;\n    next.prev = elem;\n    elem.next = next;\n    next.parent = parent;\n    if (currNext) {\n        currNext.prev = next;\n        if (parent) {\n            var childs = parent.children;\n            childs.splice(childs.lastIndexOf(currNext), 0, next);\n        }\n    }\n    else if (parent) {\n        parent.children.push(next);\n    }\n}\nexports.append = append;\n/**\n * Prepend a child to an element.\n *\n * @category Manipulation\n * @param parent The element to prepend before.\n * @param child The element to be added as a child.\n */\nfunction prependChild(parent, child) {\n    removeElement(child);\n    child.parent = parent;\n    child.prev = null;\n    if (parent.children.unshift(child) !== 1) {\n        var sibling = parent.children[1];\n        sibling.prev = child;\n        child.next = sibling;\n    }\n    else {\n        child.next = null;\n    }\n}\nexports.prependChild = prependChild;\n/**\n * Prepend an element before another.\n *\n * @category Manipulation\n * @param elem The element to prepend before.\n * @param prev The element be added.\n */\nfunction prepend(elem, prev) {\n    removeElement(prev);\n    var parent = elem.parent;\n    if (parent) {\n        var childs = parent.children;\n        childs.splice(childs.indexOf(elem), 0, prev);\n    }\n    if (elem.prev) {\n        elem.prev.next = prev;\n    }\n    prev.parent = parent;\n    prev.prev = elem.prev;\n    prev.next = elem;\n    elem.prev = prev;\n}\nexports.prepend = prepend;\n//# sourceMappingURL=manipulation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvbWFuaXB1bGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxvQkFBb0IsR0FBRyxjQUFjLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ab3J1ay9odWIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvbWFuaXB1bGF0aW9uLmpzPzVhYmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByZXBlbmQgPSBleHBvcnRzLnByZXBlbmRDaGlsZCA9IGV4cG9ydHMuYXBwZW5kID0gZXhwb3J0cy5hcHBlbmRDaGlsZCA9IGV4cG9ydHMucmVwbGFjZUVsZW1lbnQgPSBleHBvcnRzLnJlbW92ZUVsZW1lbnQgPSB2b2lkIDA7XG4vKipcbiAqIFJlbW92ZSBhbiBlbGVtZW50IGZyb20gdGhlIGRvbVxuICpcbiAqIEBjYXRlZ29yeSBNYW5pcHVsYXRpb25cbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIGJlIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbGVtKSB7XG4gICAgaWYgKGVsZW0ucHJldilcbiAgICAgICAgZWxlbS5wcmV2Lm5leHQgPSBlbGVtLm5leHQ7XG4gICAgaWYgKGVsZW0ubmV4dClcbiAgICAgICAgZWxlbS5uZXh0LnByZXYgPSBlbGVtLnByZXY7XG4gICAgaWYgKGVsZW0ucGFyZW50KSB7XG4gICAgICAgIHZhciBjaGlsZHMgPSBlbGVtLnBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGNoaWxkc0luZGV4ID0gY2hpbGRzLmxhc3RJbmRleE9mKGVsZW0pO1xuICAgICAgICBpZiAoY2hpbGRzSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY2hpbGRzLnNwbGljZShjaGlsZHNJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbS5uZXh0ID0gbnVsbDtcbiAgICBlbGVtLnByZXYgPSBudWxsO1xuICAgIGVsZW0ucGFyZW50ID0gbnVsbDtcbn1cbmV4cG9ydHMucmVtb3ZlRWxlbWVudCA9IHJlbW92ZUVsZW1lbnQ7XG4vKipcbiAqIFJlcGxhY2UgYW4gZWxlbWVudCBpbiB0aGUgZG9tXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQHBhcmFtIGVsZW0gVGhlIGVsZW1lbnQgdG8gYmUgcmVwbGFjZWRcbiAqIEBwYXJhbSByZXBsYWNlbWVudCBUaGUgZWxlbWVudCB0byBiZSBhZGRlZFxuICovXG5mdW5jdGlvbiByZXBsYWNlRWxlbWVudChlbGVtLCByZXBsYWNlbWVudCkge1xuICAgIHZhciBwcmV2ID0gKHJlcGxhY2VtZW50LnByZXYgPSBlbGVtLnByZXYpO1xuICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHByZXYubmV4dCA9IHJlcGxhY2VtZW50O1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IChyZXBsYWNlbWVudC5uZXh0ID0gZWxlbS5uZXh0KTtcbiAgICBpZiAobmV4dCkge1xuICAgICAgICBuZXh0LnByZXYgPSByZXBsYWNlbWVudDtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IChyZXBsYWNlbWVudC5wYXJlbnQgPSBlbGVtLnBhcmVudCk7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGRzID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBjaGlsZHNbY2hpbGRzLmxhc3RJbmRleE9mKGVsZW0pXSA9IHJlcGxhY2VtZW50O1xuICAgICAgICBlbGVtLnBhcmVudCA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBsYWNlRWxlbWVudCA9IHJlcGxhY2VFbGVtZW50O1xuLyoqXG4gKiBBcHBlbmQgYSBjaGlsZCB0byBhbiBlbGVtZW50LlxuICpcbiAqIEBjYXRlZ29yeSBNYW5pcHVsYXRpb25cbiAqIEBwYXJhbSBwYXJlbnQgVGhlIGVsZW1lbnQgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIGNoaWxkIFRoZSBlbGVtZW50IHRvIGJlIGFkZGVkIGFzIGEgY2hpbGQuXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgICByZW1vdmVFbGVtZW50KGNoaWxkKTtcbiAgICBjaGlsZC5uZXh0ID0gbnVsbDtcbiAgICBjaGlsZC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgaWYgKHBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKSA+IDEpIHtcbiAgICAgICAgdmFyIHNpYmxpbmcgPSBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDJdO1xuICAgICAgICBzaWJsaW5nLm5leHQgPSBjaGlsZDtcbiAgICAgICAgY2hpbGQucHJldiA9IHNpYmxpbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZC5wcmV2ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmFwcGVuZENoaWxkID0gYXBwZW5kQ2hpbGQ7XG4vKipcbiAqIEFwcGVuZCBhbiBlbGVtZW50IGFmdGVyIGFub3RoZXIuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQHBhcmFtIGVsZW0gVGhlIGVsZW1lbnQgdG8gYXBwZW5kIGFmdGVyLlxuICogQHBhcmFtIG5leHQgVGhlIGVsZW1lbnQgYmUgYWRkZWQuXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZChlbGVtLCBuZXh0KSB7XG4gICAgcmVtb3ZlRWxlbWVudChuZXh0KTtcbiAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnQ7XG4gICAgdmFyIGN1cnJOZXh0ID0gZWxlbS5uZXh0O1xuICAgIG5leHQubmV4dCA9IGN1cnJOZXh0O1xuICAgIG5leHQucHJldiA9IGVsZW07XG4gICAgZWxlbS5uZXh0ID0gbmV4dDtcbiAgICBuZXh0LnBhcmVudCA9IHBhcmVudDtcbiAgICBpZiAoY3Vyck5leHQpIHtcbiAgICAgICAgY3Vyck5leHQucHJldiA9IG5leHQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHMgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgICBjaGlsZHMuc3BsaWNlKGNoaWxkcy5sYXN0SW5kZXhPZihjdXJyTmV4dCksIDAsIG5leHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChuZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLmFwcGVuZCA9IGFwcGVuZDtcbi8qKlxuICogUHJlcGVuZCBhIGNoaWxkIHRvIGFuIGVsZW1lbnQuXG4gKlxuICogQGNhdGVnb3J5IE1hbmlwdWxhdGlvblxuICogQHBhcmFtIHBhcmVudCBUaGUgZWxlbWVudCB0byBwcmVwZW5kIGJlZm9yZS5cbiAqIEBwYXJhbSBjaGlsZCBUaGUgZWxlbWVudCB0byBiZSBhZGRlZCBhcyBhIGNoaWxkLlxuICovXG5mdW5jdGlvbiBwcmVwZW5kQ2hpbGQocGFyZW50LCBjaGlsZCkge1xuICAgIHJlbW92ZUVsZW1lbnQoY2hpbGQpO1xuICAgIGNoaWxkLnBhcmVudCA9IHBhcmVudDtcbiAgICBjaGlsZC5wcmV2ID0gbnVsbDtcbiAgICBpZiAocGFyZW50LmNoaWxkcmVuLnVuc2hpZnQoY2hpbGQpICE9PSAxKSB7XG4gICAgICAgIHZhciBzaWJsaW5nID0gcGFyZW50LmNoaWxkcmVuWzFdO1xuICAgICAgICBzaWJsaW5nLnByZXYgPSBjaGlsZDtcbiAgICAgICAgY2hpbGQubmV4dCA9IHNpYmxpbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZC5uZXh0ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLnByZXBlbmRDaGlsZCA9IHByZXBlbmRDaGlsZDtcbi8qKlxuICogUHJlcGVuZCBhbiBlbGVtZW50IGJlZm9yZSBhbm90aGVyLlxuICpcbiAqIEBjYXRlZ29yeSBNYW5pcHVsYXRpb25cbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIHByZXBlbmQgYmVmb3JlLlxuICogQHBhcmFtIHByZXYgVGhlIGVsZW1lbnQgYmUgYWRkZWQuXG4gKi9cbmZ1bmN0aW9uIHByZXBlbmQoZWxlbSwgcHJldikge1xuICAgIHJlbW92ZUVsZW1lbnQocHJldik7XG4gICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50O1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGNoaWxkcyA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY2hpbGRzLnNwbGljZShjaGlsZHMuaW5kZXhPZihlbGVtKSwgMCwgcHJldik7XG4gICAgfVxuICAgIGlmIChlbGVtLnByZXYpIHtcbiAgICAgICAgZWxlbS5wcmV2Lm5leHQgPSBwcmV2O1xuICAgIH1cbiAgICBwcmV2LnBhcmVudCA9IHBhcmVudDtcbiAgICBwcmV2LnByZXYgPSBlbGVtLnByZXY7XG4gICAgcHJldi5uZXh0ID0gZWxlbTtcbiAgICBlbGVtLnByZXYgPSBwcmV2O1xufVxuZXhwb3J0cy5wcmVwZW5kID0gcHJlcGVuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hbmlwdWxhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/manipulation.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/querying.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/htmlparser2/node_modules/domutils/lib/querying.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/../../../node_modules/domhandler/lib/index.js\");\n/**\n * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param node Node to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction filter(test, node, recurse, limit) {\n    if (recurse === void 0) { recurse = true; }\n    if (limit === void 0) { limit = Infinity; }\n    return find(test, Array.isArray(node) ? node : [node], recurse, limit);\n}\nexports.filter = filter;\n/**\n * Search an array of nodes and their children for nodes passing a test function.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction find(test, nodes, recurse, limit) {\n    var result = [];\n    /** Stack of the arrays we are looking at. */\n    var nodeStack = [nodes];\n    /** Stack of the indices within the arrays. */\n    var indexStack = [0];\n    for (;;) {\n        // First, check if the current array has any more elements to look at.\n        if (indexStack[0] >= nodeStack[0].length) {\n            // If we have no more arrays to look at, we are done.\n            if (indexStack.length === 1) {\n                return result;\n            }\n            // Otherwise, remove the current array from the stack.\n            nodeStack.shift();\n            indexStack.shift();\n            // Loop back to the start to continue with the next array.\n            continue;\n        }\n        var elem = nodeStack[0][indexStack[0]++];\n        if (test(elem)) {\n            result.push(elem);\n            if (--limit <= 0)\n                return result;\n        }\n        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {\n            /*\n             * Add the children to the stack. We are depth-first, so this is\n             * the next array we look at.\n             */\n            indexStack.unshift(0);\n            nodeStack.unshift(elem.children);\n        }\n    }\n}\nexports.find = find;\n/**\n * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns The first node in the array that passes `test`.\n * @deprecated Use `Array.prototype.find` directly.\n */\nfunction findOneChild(test, nodes) {\n    return nodes.find(test);\n}\nexports.findOneChild = findOneChild;\n/**\n * Finds one element in a tree that passes a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Node or array of nodes to search.\n * @param recurse Also consider child nodes.\n * @returns The first node that passes `test`.\n */\nfunction findOne(test, nodes, recurse) {\n    if (recurse === void 0) { recurse = true; }\n    var elem = null;\n    for (var i = 0; i < nodes.length && !elem; i++) {\n        var node = nodes[i];\n        if (!(0, domhandler_1.isTag)(node)) {\n            continue;\n        }\n        else if (test(node)) {\n            elem = node;\n        }\n        else if (recurse && node.children.length > 0) {\n            elem = findOne(test, node.children, true);\n        }\n    }\n    return elem;\n}\nexports.findOne = findOne;\n/**\n * Checks if a tree of nodes contains at least one node passing a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns Whether a tree of nodes contains at least one node passing the test.\n */\nfunction existsOne(test, nodes) {\n    return nodes.some(function (checked) {\n        return (0, domhandler_1.isTag)(checked) &&\n            (test(checked) || existsOne(test, checked.children));\n    });\n}\nexports.existsOne = existsOne;\n/**\n * Search an array of nodes and their children for elements passing a test function.\n *\n * Same as `find`, but limited to elements and with less options, leading to reduced complexity.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns All nodes passing `test`.\n */\nfunction findAll(test, nodes) {\n    var result = [];\n    var nodeStack = [nodes];\n    var indexStack = [0];\n    for (;;) {\n        if (indexStack[0] >= nodeStack[0].length) {\n            if (nodeStack.length === 1) {\n                return result;\n            }\n            // Otherwise, remove the current array from the stack.\n            nodeStack.shift();\n            indexStack.shift();\n            // Loop back to the start to continue with the next array.\n            continue;\n        }\n        var elem = nodeStack[0][indexStack[0]++];\n        if (!(0, domhandler_1.isTag)(elem))\n            continue;\n        if (test(elem))\n            result.push(elem);\n        if (elem.children.length > 0) {\n            indexStack.unshift(0);\n            nodeStack.unshift(elem.children);\n        }\n    }\n}\nexports.findAll = findAll;\n//# sourceMappingURL=querying.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvcXVlcnlpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLGlCQUFpQixHQUFHLGVBQWUsR0FBRyxvQkFBb0IsR0FBRyxZQUFZLEdBQUcsY0FBYztBQUM1RyxtQkFBbUIsbUJBQU8sQ0FBQyx1RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG9ydWsvaHViLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9ub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL3F1ZXJ5aW5nLmpzPzA4NDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZpbmRBbGwgPSBleHBvcnRzLmV4aXN0c09uZSA9IGV4cG9ydHMuZmluZE9uZSA9IGV4cG9ydHMuZmluZE9uZUNoaWxkID0gZXhwb3J0cy5maW5kID0gZXhwb3J0cy5maWx0ZXIgPSB2b2lkIDA7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcImRvbWhhbmRsZXJcIik7XG4vKipcbiAqIFNlYXJjaCBhIG5vZGUgYW5kIGl0cyBjaGlsZHJlbiBmb3Igbm9kZXMgcGFzc2luZyBhIHRlc3QgZnVuY3Rpb24uIElmIGBub2RlYCBpcyBub3QgYW4gYXJyYXksIGl0IHdpbGwgYmUgd3JhcHBlZCBpbiBvbmUuXG4gKlxuICogQGNhdGVnb3J5IFF1ZXJ5aW5nXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBzZWFyY2guIFdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBzZXQgaWYgaXQgbWF0Y2hlcy5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKiBAcGFyYW0gbGltaXQgTWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgdG8gcmV0dXJuLlxuICogQHJldHVybnMgQWxsIG5vZGVzIHBhc3NpbmcgYHRlc3RgLlxuICovXG5mdW5jdGlvbiBmaWx0ZXIodGVzdCwgbm9kZSwgcmVjdXJzZSwgbGltaXQpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSB0cnVlOyB9XG4gICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSBJbmZpbml0eTsgfVxuICAgIHJldHVybiBmaW5kKHRlc3QsIEFycmF5LmlzQXJyYXkobm9kZSkgPyBub2RlIDogW25vZGVdLCByZWN1cnNlLCBsaW1pdCk7XG59XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbi8qKlxuICogU2VhcmNoIGFuIGFycmF5IG9mIG5vZGVzIGFuZCB0aGVpciBjaGlsZHJlbiBmb3Igbm9kZXMgcGFzc2luZyBhIHRlc3QgZnVuY3Rpb24uXG4gKlxuICogQGNhdGVnb3J5IFF1ZXJ5aW5nXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIG5vZGVzIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKiBAcGFyYW0gbGltaXQgTWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgdG8gcmV0dXJuLlxuICogQHJldHVybnMgQWxsIG5vZGVzIHBhc3NpbmcgYHRlc3RgLlxuICovXG5mdW5jdGlvbiBmaW5kKHRlc3QsIG5vZGVzLCByZWN1cnNlLCBsaW1pdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAvKiogU3RhY2sgb2YgdGhlIGFycmF5cyB3ZSBhcmUgbG9va2luZyBhdC4gKi9cbiAgICB2YXIgbm9kZVN0YWNrID0gW25vZGVzXTtcbiAgICAvKiogU3RhY2sgb2YgdGhlIGluZGljZXMgd2l0aGluIHRoZSBhcnJheXMuICovXG4gICAgdmFyIGluZGV4U3RhY2sgPSBbMF07XG4gICAgZm9yICg7Oykge1xuICAgICAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdGhlIGN1cnJlbnQgYXJyYXkgaGFzIGFueSBtb3JlIGVsZW1lbnRzIHRvIGxvb2sgYXQuXG4gICAgICAgIGlmIChpbmRleFN0YWNrWzBdID49IG5vZGVTdGFja1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbm8gbW9yZSBhcnJheXMgdG8gbG9vayBhdCwgd2UgYXJlIGRvbmUuXG4gICAgICAgICAgICBpZiAoaW5kZXhTdGFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCByZW1vdmUgdGhlIGN1cnJlbnQgYXJyYXkgZnJvbSB0aGUgc3RhY2suXG4gICAgICAgICAgICBub2RlU3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgIGluZGV4U3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgIC8vIExvb3AgYmFjayB0byB0aGUgc3RhcnQgdG8gY29udGludWUgd2l0aCB0aGUgbmV4dCBhcnJheS5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtID0gbm9kZVN0YWNrWzBdW2luZGV4U3RhY2tbMF0rK107XG4gICAgICAgIGlmICh0ZXN0KGVsZW0pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChlbGVtKTtcbiAgICAgICAgICAgIGlmICgtLWxpbWl0IDw9IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdXJzZSAmJiAoMCwgZG9taGFuZGxlcl8xLmhhc0NoaWxkcmVuKShlbGVtKSAmJiBlbGVtLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBBZGQgdGhlIGNoaWxkcmVuIHRvIHRoZSBzdGFjay4gV2UgYXJlIGRlcHRoLWZpcnN0LCBzbyB0aGlzIGlzXG4gICAgICAgICAgICAgKiB0aGUgbmV4dCBhcnJheSB3ZSBsb29rIGF0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbmRleFN0YWNrLnVuc2hpZnQoMCk7XG4gICAgICAgICAgICBub2RlU3RhY2sudW5zaGlmdChlbGVtLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZmluZCA9IGZpbmQ7XG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBlbGVtZW50IGluc2lkZSBvZiBhbiBhcnJheSB0aGF0IG1hdGNoZXMgYSB0ZXN0IGZ1bmN0aW9uLiBUaGlzIGlzIGFuIGFsaWFzIGZvciBgQXJyYXkucHJvdG90eXBlLmZpbmRgLlxuICpcbiAqIEBjYXRlZ29yeSBRdWVyeWluZ1xuICogQHBhcmFtIHRlc3QgRnVuY3Rpb24gdG8gdGVzdCBub2RlcyBvbi5cbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBub2RlcyB0byBzZWFyY2guXG4gKiBAcmV0dXJucyBUaGUgZmlyc3Qgbm9kZSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgYHRlc3RgLlxuICogQGRlcHJlY2F0ZWQgVXNlIGBBcnJheS5wcm90b3R5cGUuZmluZGAgZGlyZWN0bHkuXG4gKi9cbmZ1bmN0aW9uIGZpbmRPbmVDaGlsZCh0ZXN0LCBub2Rlcykge1xuICAgIHJldHVybiBub2Rlcy5maW5kKHRlc3QpO1xufVxuZXhwb3J0cy5maW5kT25lQ2hpbGQgPSBmaW5kT25lQ2hpbGQ7XG4vKipcbiAqIEZpbmRzIG9uZSBlbGVtZW50IGluIGEgdHJlZSB0aGF0IHBhc3NlcyBhIHRlc3QuXG4gKlxuICogQGNhdGVnb3J5IFF1ZXJ5aW5nXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGVzIE5vZGUgb3IgYXJyYXkgb2Ygbm9kZXMgdG8gc2VhcmNoLlxuICogQHBhcmFtIHJlY3Vyc2UgQWxzbyBjb25zaWRlciBjaGlsZCBub2Rlcy5cbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBub2RlIHRoYXQgcGFzc2VzIGB0ZXN0YC5cbiAqL1xuZnVuY3Rpb24gZmluZE9uZSh0ZXN0LCBub2RlcywgcmVjdXJzZSkge1xuICAgIGlmIChyZWN1cnNlID09PSB2b2lkIDApIHsgcmVjdXJzZSA9IHRydWU7IH1cbiAgICB2YXIgZWxlbSA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGggJiYgIWVsZW07IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoISgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKG5vZGUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXN0KG5vZGUpKSB7XG4gICAgICAgICAgICBlbGVtID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWN1cnNlICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZWxlbSA9IGZpbmRPbmUodGVzdCwgbm9kZS5jaGlsZHJlbiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW07XG59XG5leHBvcnRzLmZpbmRPbmUgPSBmaW5kT25lO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB0cmVlIG9mIG5vZGVzIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBub2RlIHBhc3NpbmcgYSB0ZXN0LlxuICpcbiAqIEBjYXRlZ29yeSBRdWVyeWluZ1xuICogQHBhcmFtIHRlc3QgRnVuY3Rpb24gdG8gdGVzdCBub2RlcyBvbi5cbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBub2RlcyB0byBzZWFyY2guXG4gKiBAcmV0dXJucyBXaGV0aGVyIGEgdHJlZSBvZiBub2RlcyBjb250YWlucyBhdCBsZWFzdCBvbmUgbm9kZSBwYXNzaW5nIHRoZSB0ZXN0LlxuICovXG5mdW5jdGlvbiBleGlzdHNPbmUodGVzdCwgbm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMuc29tZShmdW5jdGlvbiAoY2hlY2tlZCkge1xuICAgICAgICByZXR1cm4gKDAsIGRvbWhhbmRsZXJfMS5pc1RhZykoY2hlY2tlZCkgJiZcbiAgICAgICAgICAgICh0ZXN0KGNoZWNrZWQpIHx8IGV4aXN0c09uZSh0ZXN0LCBjaGVja2VkLmNoaWxkcmVuKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmV4aXN0c09uZSA9IGV4aXN0c09uZTtcbi8qKlxuICogU2VhcmNoIGFuIGFycmF5IG9mIG5vZGVzIGFuZCB0aGVpciBjaGlsZHJlbiBmb3IgZWxlbWVudHMgcGFzc2luZyBhIHRlc3QgZnVuY3Rpb24uXG4gKlxuICogU2FtZSBhcyBgZmluZGAsIGJ1dCBsaW1pdGVkIHRvIGVsZW1lbnRzIGFuZCB3aXRoIGxlc3Mgb3B0aW9ucywgbGVhZGluZyB0byByZWR1Y2VkIGNvbXBsZXhpdHkuXG4gKlxuICogQGNhdGVnb3J5IFF1ZXJ5aW5nXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIG5vZGVzIHRvIHNlYXJjaC5cbiAqIEByZXR1cm5zIEFsbCBub2RlcyBwYXNzaW5nIGB0ZXN0YC5cbiAqL1xuZnVuY3Rpb24gZmluZEFsbCh0ZXN0LCBub2Rlcykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbm9kZVN0YWNrID0gW25vZGVzXTtcbiAgICB2YXIgaW5kZXhTdGFjayA9IFswXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChpbmRleFN0YWNrWzBdID49IG5vZGVTdGFja1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChub2RlU3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgcmVtb3ZlIHRoZSBjdXJyZW50IGFycmF5IGZyb20gdGhlIHN0YWNrLlxuICAgICAgICAgICAgbm9kZVN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICBpbmRleFN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAvLyBMb29wIGJhY2sgdG8gdGhlIHN0YXJ0IHRvIGNvbnRpbnVlIHdpdGggdGhlIG5leHQgYXJyYXkuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbSA9IG5vZGVTdGFja1swXVtpbmRleFN0YWNrWzBdKytdO1xuICAgICAgICBpZiAoISgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKGVsZW0pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0ZXN0KGVsZW0pKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbSk7XG4gICAgICAgIGlmIChlbGVtLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGluZGV4U3RhY2sudW5zaGlmdCgwKTtcbiAgICAgICAgICAgIG5vZGVTdGFjay51bnNoaWZ0KGVsZW0uY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5maW5kQWxsID0gZmluZEFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5aW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/querying.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/stringify.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/htmlparser2/node_modules/domutils/lib/stringify.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/../../../node_modules/domhandler/lib/index.js\");\nvar dom_serializer_1 = __importDefault(__webpack_require__(/*! dom-serializer */ \"(rsc)/../../../node_modules/htmlparser2/node_modules/dom-serializer/lib/index.js\"));\nvar domelementtype_1 = __webpack_require__(/*! domelementtype */ \"(rsc)/../../../node_modules/domelementtype/lib/index.js\");\n/**\n * @category Stringify\n * @deprecated Use the `dom-serializer` module directly.\n * @param node Node to get the outer HTML of.\n * @param options Options for serialization.\n * @returns `node`'s outer HTML.\n */\nfunction getOuterHTML(node, options) {\n    return (0, dom_serializer_1.default)(node, options);\n}\nexports.getOuterHTML = getOuterHTML;\n/**\n * @category Stringify\n * @deprecated Use the `dom-serializer` module directly.\n * @param node Node to get the inner HTML of.\n * @param options Options for serialization.\n * @returns `node`'s inner HTML.\n */\nfunction getInnerHTML(node, options) {\n    return (0, domhandler_1.hasChildren)(node)\n        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join(\"\")\n        : \"\";\n}\nexports.getInnerHTML = getInnerHTML;\n/**\n * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.\n *\n * @category Stringify\n * @deprecated Use `textContent` instead.\n * @param node Node to get the inner text of.\n * @returns `node`'s inner text.\n */\nfunction getText(node) {\n    if (Array.isArray(node))\n        return node.map(getText).join(\"\");\n    if ((0, domhandler_1.isTag)(node))\n        return node.name === \"br\" ? \"\\n\" : getText(node.children);\n    if ((0, domhandler_1.isCDATA)(node))\n        return getText(node.children);\n    if ((0, domhandler_1.isText)(node))\n        return node.data;\n    return \"\";\n}\nexports.getText = getText;\n/**\n * Get a node's text content. Ignores comments.\n *\n * @category Stringify\n * @param node Node to get the text content of.\n * @returns `node`'s text content.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}\n */\nfunction textContent(node) {\n    if (Array.isArray(node))\n        return node.map(textContent).join(\"\");\n    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {\n        return textContent(node.children);\n    }\n    if ((0, domhandler_1.isText)(node))\n        return node.data;\n    return \"\";\n}\nexports.textContent = textContent;\n/**\n * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.\n *\n * @category Stringify\n * @param node Node to get the inner text of.\n * @returns `node`'s inner text.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}\n */\nfunction innerText(node) {\n    if (Array.isArray(node))\n        return node.map(innerText).join(\"\");\n    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {\n        return innerText(node.children);\n    }\n    if ((0, domhandler_1.isText)(node))\n        return node.data;\n    return \"\";\n}\nexports.innerText = innerText;\n//# sourceMappingURL=stringify.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLG9CQUFvQixHQUFHLG9CQUFvQjtBQUN2RyxtQkFBbUIsbUJBQU8sQ0FBQyx1RUFBWTtBQUN2Qyx1Q0FBdUMsbUJBQU8sQ0FBQyx3R0FBZ0I7QUFDL0QsdUJBQXVCLG1CQUFPLENBQUMsK0VBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQ0FBcUM7QUFDbkY7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BvcnVrL2h1Yi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9zdHJpbmdpZnkuanM/MjAxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5uZXJUZXh0ID0gZXhwb3J0cy50ZXh0Q29udGVudCA9IGV4cG9ydHMuZ2V0VGV4dCA9IGV4cG9ydHMuZ2V0SW5uZXJIVE1MID0gZXhwb3J0cy5nZXRPdXRlckhUTUwgPSB2b2lkIDA7XG52YXIgZG9taGFuZGxlcl8xID0gcmVxdWlyZShcImRvbWhhbmRsZXJcIik7XG52YXIgZG9tX3NlcmlhbGl6ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZG9tLXNlcmlhbGl6ZXJcIikpO1xudmFyIGRvbWVsZW1lbnR0eXBlXzEgPSByZXF1aXJlKFwiZG9tZWxlbWVudHR5cGVcIik7XG4vKipcbiAqIEBjYXRlZ29yeSBTdHJpbmdpZnlcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYGRvbS1zZXJpYWxpemVyYCBtb2R1bGUgZGlyZWN0bHkuXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGdldCB0aGUgb3V0ZXIgSFRNTCBvZi5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHNlcmlhbGl6YXRpb24uXG4gKiBAcmV0dXJucyBgbm9kZWAncyBvdXRlciBIVE1MLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiAoMCwgZG9tX3NlcmlhbGl6ZXJfMS5kZWZhdWx0KShub2RlLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZ2V0T3V0ZXJIVE1MID0gZ2V0T3V0ZXJIVE1MO1xuLyoqXG4gKiBAY2F0ZWdvcnkgU3RyaW5naWZ5XG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBkb20tc2VyaWFsaXplcmAgbW9kdWxlIGRpcmVjdGx5LlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBnZXQgdGhlIGlubmVyIEhUTUwgb2YuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBzZXJpYWxpemF0aW9uLlxuICogQHJldHVybnMgYG5vZGVgJ3MgaW5uZXIgSFRNTC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5uZXJIVE1MKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKDAsIGRvbWhhbmRsZXJfMS5oYXNDaGlsZHJlbikobm9kZSlcbiAgICAgICAgPyBub2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gZ2V0T3V0ZXJIVE1MKG5vZGUsIG9wdGlvbnMpOyB9KS5qb2luKFwiXCIpXG4gICAgICAgIDogXCJcIjtcbn1cbmV4cG9ydHMuZ2V0SW5uZXJIVE1MID0gZ2V0SW5uZXJIVE1MO1xuLyoqXG4gKiBHZXQgYSBub2RlJ3MgaW5uZXIgdGV4dC4gU2FtZSBhcyBgdGV4dENvbnRlbnRgLCBidXQgaW5zZXJ0cyBuZXdsaW5lcyBmb3IgYDxicj5gIHRhZ3MuIElnbm9yZXMgY29tbWVudHMuXG4gKlxuICogQGNhdGVnb3J5IFN0cmluZ2lmeVxuICogQGRlcHJlY2F0ZWQgVXNlIGB0ZXh0Q29udGVudGAgaW5zdGVhZC5cbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gZ2V0IHRoZSBpbm5lciB0ZXh0IG9mLlxuICogQHJldHVybnMgYG5vZGVgJ3MgaW5uZXIgdGV4dC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dChub2RlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpXG4gICAgICAgIHJldHVybiBub2RlLm1hcChnZXRUZXh0KS5qb2luKFwiXCIpO1xuICAgIGlmICgoMCwgZG9taGFuZGxlcl8xLmlzVGFnKShub2RlKSlcbiAgICAgICAgcmV0dXJuIG5vZGUubmFtZSA9PT0gXCJiclwiID8gXCJcXG5cIiA6IGdldFRleHQobm9kZS5jaGlsZHJlbik7XG4gICAgaWYgKCgwLCBkb21oYW5kbGVyXzEuaXNDREFUQSkobm9kZSkpXG4gICAgICAgIHJldHVybiBnZXRUZXh0KG5vZGUuY2hpbGRyZW4pO1xuICAgIGlmICgoMCwgZG9taGFuZGxlcl8xLmlzVGV4dCkobm9kZSkpXG4gICAgICAgIHJldHVybiBub2RlLmRhdGE7XG4gICAgcmV0dXJuIFwiXCI7XG59XG5leHBvcnRzLmdldFRleHQgPSBnZXRUZXh0O1xuLyoqXG4gKiBHZXQgYSBub2RlJ3MgdGV4dCBjb250ZW50LiBJZ25vcmVzIGNvbW1lbnRzLlxuICpcbiAqIEBjYXRlZ29yeSBTdHJpbmdpZnlcbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gZ2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YuXG4gKiBAcmV0dXJucyBgbm9kZWAncyB0ZXh0IGNvbnRlbnQuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS90ZXh0Q29udGVudH1cbiAqL1xuZnVuY3Rpb24gdGV4dENvbnRlbnQobm9kZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZS5tYXAodGV4dENvbnRlbnQpLmpvaW4oXCJcIik7XG4gICAgaWYgKCgwLCBkb21oYW5kbGVyXzEuaGFzQ2hpbGRyZW4pKG5vZGUpICYmICEoMCwgZG9taGFuZGxlcl8xLmlzQ29tbWVudCkobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRleHRDb250ZW50KG5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoKDAsIGRvbWhhbmRsZXJfMS5pc1RleHQpKG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZS5kYXRhO1xuICAgIHJldHVybiBcIlwiO1xufVxuZXhwb3J0cy50ZXh0Q29udGVudCA9IHRleHRDb250ZW50O1xuLyoqXG4gKiBHZXQgYSBub2RlJ3MgaW5uZXIgdGV4dCwgaWdub3JpbmcgYDxzY3JpcHQ+YCBhbmQgYDxzdHlsZT5gIHRhZ3MuIElnbm9yZXMgY29tbWVudHMuXG4gKlxuICogQGNhdGVnb3J5IFN0cmluZ2lmeVxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBnZXQgdGhlIGlubmVyIHRleHQgb2YuXG4gKiBAcmV0dXJucyBgbm9kZWAncyBpbm5lciB0ZXh0LlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvaW5uZXJUZXh0fVxuICovXG5mdW5jdGlvbiBpbm5lclRleHQobm9kZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZS5tYXAoaW5uZXJUZXh0KS5qb2luKFwiXCIpO1xuICAgIGlmICgoMCwgZG9taGFuZGxlcl8xLmhhc0NoaWxkcmVuKShub2RlKSAmJiAobm9kZS50eXBlID09PSBkb21lbGVtZW50dHlwZV8xLkVsZW1lbnRUeXBlLlRhZyB8fCAoMCwgZG9taGFuZGxlcl8xLmlzQ0RBVEEpKG5vZGUpKSkge1xuICAgICAgICByZXR1cm4gaW5uZXJUZXh0KG5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoKDAsIGRvbWhhbmRsZXJfMS5pc1RleHQpKG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZS5kYXRhO1xuICAgIHJldHVybiBcIlwiO1xufVxuZXhwb3J0cy5pbm5lclRleHQgPSBpbm5lclRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdpZnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/stringify.js\n");

/***/ }),

/***/ "(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/traversal.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/htmlparser2/node_modules/domutils/lib/traversal.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"(rsc)/../../../node_modules/domhandler/lib/index.js\");\n/**\n * Get a node's children.\n *\n * @category Traversal\n * @param elem Node to get the children of.\n * @returns `elem`'s children, or an empty array.\n */\nfunction getChildren(elem) {\n    return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];\n}\nexports.getChildren = getChildren;\n/**\n * Get a node's parent.\n *\n * @category Traversal\n * @param elem Node to get the parent of.\n * @returns `elem`'s parent node, or `null` if `elem` is a root node.\n */\nfunction getParent(elem) {\n    return elem.parent || null;\n}\nexports.getParent = getParent;\n/**\n * Gets an elements siblings, including the element itself.\n *\n * Attempts to get the children through the element's parent first. If we don't\n * have a parent (the element is a root node), we walk the element's `prev` &\n * `next` to get all remaining nodes.\n *\n * @category Traversal\n * @param elem Element to get the siblings of.\n * @returns `elem`'s siblings, including `elem`.\n */\nfunction getSiblings(elem) {\n    var _a, _b;\n    var parent = getParent(elem);\n    if (parent != null)\n        return getChildren(parent);\n    var siblings = [elem];\n    var prev = elem.prev, next = elem.next;\n    while (prev != null) {\n        siblings.unshift(prev);\n        (_a = prev, prev = _a.prev);\n    }\n    while (next != null) {\n        siblings.push(next);\n        (_b = next, next = _b.next);\n    }\n    return siblings;\n}\nexports.getSiblings = getSiblings;\n/**\n * Gets an attribute from an element.\n *\n * @category Traversal\n * @param elem Element to check.\n * @param name Attribute name to retrieve.\n * @returns The element's attribute value, or `undefined`.\n */\nfunction getAttributeValue(elem, name) {\n    var _a;\n    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];\n}\nexports.getAttributeValue = getAttributeValue;\n/**\n * Checks whether an element has an attribute.\n *\n * @category Traversal\n * @param elem Element to check.\n * @param name Attribute name to look for.\n * @returns Returns whether `elem` has the attribute `name`.\n */\nfunction hasAttrib(elem, name) {\n    return (elem.attribs != null &&\n        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&\n        elem.attribs[name] != null);\n}\nexports.hasAttrib = hasAttrib;\n/**\n * Get the tag name of an element.\n *\n * @category Traversal\n * @param elem The element to get the name for.\n * @returns The tag name of `elem`.\n */\nfunction getName(elem) {\n    return elem.name;\n}\nexports.getName = getName;\n/**\n * Returns the next element sibling of a node.\n *\n * @category Traversal\n * @param elem The element to get the next sibling of.\n * @returns `elem`'s next sibling that is a tag, or `null` if there is no next\n * sibling.\n */\nfunction nextElementSibling(elem) {\n    var _a;\n    var next = elem.next;\n    while (next !== null && !(0, domhandler_1.isTag)(next))\n        (_a = next, next = _a.next);\n    return next;\n}\nexports.nextElementSibling = nextElementSibling;\n/**\n * Returns the previous element sibling of a node.\n *\n * @category Traversal\n * @param elem The element to get the previous sibling of.\n * @returns `elem`'s previous sibling that is a tag, or `null` if there is no\n * previous sibling.\n */\nfunction prevElementSibling(elem) {\n    var _a;\n    var prev = elem.prev;\n    while (prev !== null && !(0, domhandler_1.isTag)(prev))\n        (_a = prev, prev = _a.prev);\n    return prev;\n}\nexports.prevElementSibling = prevElementSibling;\n//# sourceMappingURL=traversal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvdHJhdmVyc2FsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRyx5QkFBeUIsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUI7QUFDekwsbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ab3J1ay9odWIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvdHJhdmVyc2FsLmpzP2NkZDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByZXZFbGVtZW50U2libGluZyA9IGV4cG9ydHMubmV4dEVsZW1lbnRTaWJsaW5nID0gZXhwb3J0cy5nZXROYW1lID0gZXhwb3J0cy5oYXNBdHRyaWIgPSBleHBvcnRzLmdldEF0dHJpYnV0ZVZhbHVlID0gZXhwb3J0cy5nZXRTaWJsaW5ncyA9IGV4cG9ydHMuZ2V0UGFyZW50ID0gZXhwb3J0cy5nZXRDaGlsZHJlbiA9IHZvaWQgMDtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiZG9taGFuZGxlclwiKTtcbi8qKlxuICogR2V0IGEgbm9kZSdzIGNoaWxkcmVuLlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzYWxcbiAqIEBwYXJhbSBlbGVtIE5vZGUgdG8gZ2V0IHRoZSBjaGlsZHJlbiBvZi5cbiAqIEByZXR1cm5zIGBlbGVtYCdzIGNoaWxkcmVuLCBvciBhbiBlbXB0eSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oZWxlbSkge1xuICAgIHJldHVybiAoMCwgZG9taGFuZGxlcl8xLmhhc0NoaWxkcmVuKShlbGVtKSA/IGVsZW0uY2hpbGRyZW4gOiBbXTtcbn1cbmV4cG9ydHMuZ2V0Q2hpbGRyZW4gPSBnZXRDaGlsZHJlbjtcbi8qKlxuICogR2V0IGEgbm9kZSdzIHBhcmVudC5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2FsXG4gKiBAcGFyYW0gZWxlbSBOb2RlIHRvIGdldCB0aGUgcGFyZW50IG9mLlxuICogQHJldHVybnMgYGVsZW1gJ3MgcGFyZW50IG5vZGUsIG9yIGBudWxsYCBpZiBgZWxlbWAgaXMgYSByb290IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudChlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0ucGFyZW50IHx8IG51bGw7XG59XG5leHBvcnRzLmdldFBhcmVudCA9IGdldFBhcmVudDtcbi8qKlxuICogR2V0cyBhbiBlbGVtZW50cyBzaWJsaW5ncywgaW5jbHVkaW5nIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBBdHRlbXB0cyB0byBnZXQgdGhlIGNoaWxkcmVuIHRocm91Z2ggdGhlIGVsZW1lbnQncyBwYXJlbnQgZmlyc3QuIElmIHdlIGRvbid0XG4gKiBoYXZlIGEgcGFyZW50ICh0aGUgZWxlbWVudCBpcyBhIHJvb3Qgbm9kZSksIHdlIHdhbGsgdGhlIGVsZW1lbnQncyBgcHJldmAgJlxuICogYG5leHRgIHRvIGdldCBhbGwgcmVtYWluaW5nIG5vZGVzLlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzYWxcbiAqIEBwYXJhbSBlbGVtIEVsZW1lbnQgdG8gZ2V0IHRoZSBzaWJsaW5ncyBvZi5cbiAqIEByZXR1cm5zIGBlbGVtYCdzIHNpYmxpbmdzLCBpbmNsdWRpbmcgYGVsZW1gLlxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5ncyhlbGVtKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KGVsZW0pO1xuICAgIGlmIChwYXJlbnQgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHBhcmVudCk7XG4gICAgdmFyIHNpYmxpbmdzID0gW2VsZW1dO1xuICAgIHZhciBwcmV2ID0gZWxlbS5wcmV2LCBuZXh0ID0gZWxlbS5uZXh0O1xuICAgIHdoaWxlIChwcmV2ICE9IG51bGwpIHtcbiAgICAgICAgc2libGluZ3MudW5zaGlmdChwcmV2KTtcbiAgICAgICAgKF9hID0gcHJldiwgcHJldiA9IF9hLnByZXYpO1xuICAgIH1cbiAgICB3aGlsZSAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNpYmxpbmdzLnB1c2gobmV4dCk7XG4gICAgICAgIChfYiA9IG5leHQsIG5leHQgPSBfYi5uZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNpYmxpbmdzO1xufVxuZXhwb3J0cy5nZXRTaWJsaW5ncyA9IGdldFNpYmxpbmdzO1xuLyoqXG4gKiBHZXRzIGFuIGF0dHJpYnV0ZSBmcm9tIGFuIGVsZW1lbnQuXG4gKlxuICogQGNhdGVnb3J5IFRyYXZlcnNhbFxuICogQHBhcmFtIGVsZW0gRWxlbWVudCB0byBjaGVjay5cbiAqIEBwYXJhbSBuYW1lIEF0dHJpYnV0ZSBuYW1lIHRvIHJldHJpZXZlLlxuICogQHJldHVybnMgVGhlIGVsZW1lbnQncyBhdHRyaWJ1dGUgdmFsdWUsIG9yIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBlbGVtLmF0dHJpYnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtuYW1lXTtcbn1cbmV4cG9ydHMuZ2V0QXR0cmlidXRlVmFsdWUgPSBnZXRBdHRyaWJ1dGVWYWx1ZTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYW4gZWxlbWVudCBoYXMgYW4gYXR0cmlidXRlLlxuICpcbiAqIEBjYXRlZ29yeSBUcmF2ZXJzYWxcbiAqIEBwYXJhbSBlbGVtIEVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcGFyYW0gbmFtZSBBdHRyaWJ1dGUgbmFtZSB0byBsb29rIGZvci5cbiAqIEByZXR1cm5zIFJldHVybnMgd2hldGhlciBgZWxlbWAgaGFzIHRoZSBhdHRyaWJ1dGUgYG5hbWVgLlxuICovXG5mdW5jdGlvbiBoYXNBdHRyaWIoZWxlbSwgbmFtZSkge1xuICAgIHJldHVybiAoZWxlbS5hdHRyaWJzICE9IG51bGwgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW0uYXR0cmlicywgbmFtZSkgJiZcbiAgICAgICAgZWxlbS5hdHRyaWJzW25hbWVdICE9IG51bGwpO1xufVxuZXhwb3J0cy5oYXNBdHRyaWIgPSBoYXNBdHRyaWI7XG4vKipcbiAqIEdldCB0aGUgdGFnIG5hbWUgb2YgYW4gZWxlbWVudC5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2FsXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIG5hbWUgZm9yLlxuICogQHJldHVybnMgVGhlIHRhZyBuYW1lIG9mIGBlbGVtYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmFtZShlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0ubmFtZTtcbn1cbmV4cG9ydHMuZ2V0TmFtZSA9IGdldE5hbWU7XG4vKipcbiAqIFJldHVybnMgdGhlIG5leHQgZWxlbWVudCBzaWJsaW5nIG9mIGEgbm9kZS5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2FsXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIG5leHQgc2libGluZyBvZi5cbiAqIEByZXR1cm5zIGBlbGVtYCdzIG5leHQgc2libGluZyB0aGF0IGlzIGEgdGFnLCBvciBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gbmV4dFxuICogc2libGluZy5cbiAqL1xuZnVuY3Rpb24gbmV4dEVsZW1lbnRTaWJsaW5nKGVsZW0pIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIG5leHQgPSBlbGVtLm5leHQ7XG4gICAgd2hpbGUgKG5leHQgIT09IG51bGwgJiYgISgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKG5leHQpKVxuICAgICAgICAoX2EgPSBuZXh0LCBuZXh0ID0gX2EubmV4dCk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG5leHBvcnRzLm5leHRFbGVtZW50U2libGluZyA9IG5leHRFbGVtZW50U2libGluZztcbi8qKlxuICogUmV0dXJucyB0aGUgcHJldmlvdXMgZWxlbWVudCBzaWJsaW5nIG9mIGEgbm9kZS5cbiAqXG4gKiBAY2F0ZWdvcnkgVHJhdmVyc2FsXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YuXG4gKiBAcmV0dXJucyBgZWxlbWAncyBwcmV2aW91cyBzaWJsaW5nIHRoYXQgaXMgYSB0YWcsIG9yIGBudWxsYCBpZiB0aGVyZSBpcyBub1xuICogcHJldmlvdXMgc2libGluZy5cbiAqL1xuZnVuY3Rpb24gcHJldkVsZW1lbnRTaWJsaW5nKGVsZW0pIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHByZXYgPSBlbGVtLnByZXY7XG4gICAgd2hpbGUgKHByZXYgIT09IG51bGwgJiYgISgwLCBkb21oYW5kbGVyXzEuaXNUYWcpKHByZXYpKVxuICAgICAgICAoX2EgPSBwcmV2LCBwcmV2ID0gX2EucHJldik7XG4gICAgcmV0dXJuIHByZXY7XG59XG5leHBvcnRzLnByZXZFbGVtZW50U2libGluZyA9IHByZXZFbGVtZW50U2libGluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYXZlcnNhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../node_modules/htmlparser2/node_modules/domutils/lib/traversal.js\n");

/***/ })

};
;